apiVersion: apps/v1
kind: Deployment
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
  labels:
    app: service-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: service-controller
  template:
    metadata:
      labels:
        app: service-controller
    spec:
      serviceAccountName: service-controller
      containers:
        - name: service-controller
          image: python:3.13-alpine
          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "🔍 Installing dependencies..."
              apk add --no-cache curl
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              mv kubectl /usr/local/bin/
              pip install kubernetes pyyaml requests --quiet

              echo "🔍 Starting Service Controller..."
              python -u /app/controller.py
          env:
            - name: CLOUDFLARE_API_TOKEN
              valueFrom:
                secretKeyRef:
                  name: cloudflare-api-token
                  key: token
            - name: INGRESS_NAMESPACE
              value: ingress-nginx
            - name: INGRESS_SERVICE_NAME
              value: ingress-nginx-controller
          volumeMounts:
            - name: controller-script
              mountPath: /app
          resources:
            limits:
              memory: 256Mi
              cpu: 200m
            requests:
              memory: 128Mi
              cpu: 100m
      volumes:
        - name: controller-script
          configMap:
            name: service-controller-script
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: service-controller-script
  namespace: cloudflare-tunnel
data:
  controller.py: |-
    #!/usr/bin/env python3

    import os
    import time
    import yaml
    import subprocess
    import hashlib
    import logging
    import re
    from kubernetes import client, config, watch
    import threading

    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO').upper()
    logging.basicConfig(level=LOG_LEVEL, format="%(asctime)s %(levelname)s %(name)s %(message)s")
    logger = logging.getLogger("service-controller")
    RECONCILE_INTERVAL_SEC = int(os.environ.get('RECONCILE_INTERVAL_SEC', '300'))

    # Label constants
    DNS_ENABLED_LABEL = "dns.service-controller.io/enabled"
    DNS_HOSTNAME_LABEL = "dns.service-controller.io/hostname"
    EXPOSURE_TYPE_LABEL = "exposure.service-controller.io/type"  # "public" or "internal"

    # Exposure types
    EXPOSURE_PUBLIC = "public"
    EXPOSURE_INTERNAL = "internal"

    class ServiceController:
        def __init__(self):
            self.v1 = None
            self.apps_v1 = None
            self.tunnel_config_hash = None
            self.last_config_update = 0
            # Ingress settings for internal services
            self.ingress_namespace = os.environ.get('INGRESS_NAMESPACE', 'ingress-nginx')
            self.ingress_service_name = os.environ.get('INGRESS_SERVICE_NAME', 'ingress-nginx-controller')

        def get_service_port(self, service_name, namespace):
            """Get the port of a service"""
            try:
                service = self.v1.read_namespaced_service(service_name, namespace)
                if service.spec.ports:
                    return service.spec.ports[0].port
                return 80
            except Exception as e:
                logger.warning("Error getting port for %s.%s: %s", service_name, namespace, e)
                return 80

        def get_ingress_external_ip(self):
            """Get the external IP of the ingress controller service for internal HTTPS"""
            try:
                service = self.v1.read_namespaced_service(self.ingress_service_name, self.ingress_namespace)
                if service.status.load_balancer and service.status.load_balancer.ingress:
                    ip = service.status.load_balancer.ingress[0].ip
                    if ip:
                        return ip
                return None
            except Exception as e:
                logger.warning("Error getting external IP for ingress %s.%s: %s", self.ingress_service_name, self.ingress_namespace, e)
                return None

        def create_cloudflare_dns_route(self, hostname):
            """Create DNS route using cloudflared for public services"""
            try:
                # Skip creating if route already exists
                if self.public_route_exists(hostname):
                    logger.debug("Cloudflare DNS route already exists for %s", hostname)
                    return True

                logger.debug("Ensuring Cloudflare DNS route for %s", hostname)

                cmd = [
                    'kubectl', 'exec', '-n', 'cloudflare-tunnel',
                    'deployment/cloudflared', '--', 'cloudflared',
                    'tunnel', 'route', 'dns', '--overwrite-dns',
                    'homelab-tunnel', hostname
                ]
                result = subprocess.run(cmd, capture_output=True, text=True)
                out = (result.stdout or "") + "\n" + (result.stderr or "")
                logger.debug("DNS route cmd rc=%s out='%s'", result.returncode, out.strip())
                if result.returncode == 0:
                    # Heuristics: avoid noisy info logs; treat as ensure at debug level
                    if re.search(r"exist|already", out, re.IGNORECASE):
                        logger.debug("Cloudflare DNS route already existed for %s", hostname)
                    else:
                        logger.debug("Ensured Cloudflare DNS route for %s", hostname)
                    return True
                else:
                    logger.warning("Cloudflare DNS route creation failed for %s: %s", hostname, result.stderr.strip())
                    # Try without overwrite flag as fallback
                    cmd_fallback = [
                        'kubectl', 'exec', '-n', 'cloudflare-tunnel',
                        'deployment/cloudflared', '--', 'cloudflared',
                        'tunnel', 'route', 'dns',
                        'homelab-tunnel', hostname
                    ]
                    result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)
                    fb_out = (result_fallback.stdout or "") + "\n" + (result_fallback.stderr or "")
                    logger.debug("Fallback DNS route rc=%s out='%s'", result_fallback.returncode, fb_out.strip())
                    if result_fallback.returncode == 0:
                        if re.search(r"exist|already", fb_out, re.IGNORECASE):
                            logger.debug("Cloudflare DNS route already existed for %s (fallback)", hostname)
                        else:
                            logger.debug("Ensured Cloudflare DNS route for %s (fallback)", hostname)
                        return True
                    else:
                        logger.error("Failed to create Cloudflare DNS route for %s: %s", hostname, result_fallback.stderr.strip())
                        return False
            except subprocess.TimeoutExpired:
                logger.warning("DNS route command timed out for %s", hostname)
                return False
            except Exception as e:
                logger.exception("Error creating Cloudflare DNS route for %s: %s", hostname, e)
                return False

        def public_route_exists(self, hostname):
            """Check if a Cloudflare DNS route already exists for the hostname"""
            try:
                cmd = [
                    'kubectl', 'exec', '-n', 'cloudflare-tunnel',
                    'deployment/cloudflared', '--', 'cloudflared',
                    'tunnel', 'route', 'dns', 'homelab-tunnel', 'list'
                ]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                if result.returncode != 0:
                    logger.debug("route list failed rc=%s stderr='%s'", result.returncode, result.stderr.strip())
                    return False
                out = result.stdout or ""
                # Simple containment check; output is tabular, so contains hostname when present
                exists = hostname in out
                logger.debug("route exists for %s: %s", hostname, exists)
                return exists
            except subprocess.TimeoutExpired:
                logger.warning("Timeout checking route existence for %s", hostname)
                return False
            except Exception as e:
                logger.debug("Error checking route existence for %s: %s", hostname, e)
                return False

        def create_internal_dns_entry(self, hostname, ip_address):
            """Ensure internal DNS entry using MetalLB IP via Cloudflare API"""
            try:
                logger.debug("Ensuring internal DNS entry for %s -> %s", hostname, ip_address)

                # Get Cloudflare API credentials from environment or secret
                api_token = os.environ.get('CLOUDFLARE_API_TOKEN')
                if not api_token:
                    logger.warning("CLOUDFLARE_API_TOKEN not found in environment variables")
                    return False

                # Extract domain from hostname (e.g., "service.internal.example.com" -> "example.com")
                domain_parts = hostname.split('.')
                if len(domain_parts) < 2:
                    print(f"⚠️  Invalid hostname format: {hostname}")
                    return False

                # Get domain (last two parts: example.com)
                domain = '.'.join(domain_parts[-2:])
                subdomain = '.'.join(domain_parts[:-2]) if len(domain_parts) > 2 else '@'

                logger.debug("Domain: %s, Subdomain: %s", domain, subdomain)

                # Get zone ID for the domain
                zone_id = self.get_cloudflare_zone_id(domain, api_token)
                if not zone_id:
                    logger.error("Could not find zone ID for domain: %s", domain)
                    return False

                # Check if record already exists
                existing_record = self.get_existing_dns_record(zone_id, subdomain, domain, api_token)

                if existing_record:
                    # Update existing record if IP is different
                    if existing_record.get('content') != ip_address:
                        logger.info("Updating internal DNS record for %s -> %s", hostname, ip_address)
                        success = self.update_dns_record(zone_id, existing_record['id'], subdomain, ip_address, api_token)
                        return success
                    else:
                        logger.debug("Internal DNS record for %s already correct", hostname)
                        return True
                else:
                    # Create new record
                    logger.info("Creating internal DNS record for %s -> %s", hostname, ip_address)
                    success = self.create_dns_record(zone_id, subdomain, ip_address, api_token, domain)
                    return success

            except Exception as e:
                logger.exception("Error creating internal DNS entry for %s: %s", hostname, e)
                return False

        def get_cloudflare_zone_id(self, domain, api_token):
            """Get Cloudflare zone ID for a domain"""
            try:
                import requests

                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }

                url = f'https://api.cloudflare.com/client/v4/zones?name={domain}'
                response = requests.get(url, headers=headers, timeout=10)

                if response.status_code == 200:
                    data = response.json()
                    if data.get('success') and data.get('result'):
                        zone_id = data['result'][0]['id']
                        logger.info("Found zone ID for %s: %s", domain, zone_id)
                        return zone_id
                    else:
                        logger.error("No zone found for domain: %s", domain)
                        return None
                else:
                    logger.error("Failed to get zone ID: %s - %s", response.status_code, response.text)
                    return None

            except Exception as e:
                logger.exception("Error getting zone ID: %s", e)
                return None

        def get_existing_dns_record(self, zone_id, subdomain, domain, api_token):
            """Get existing DNS record if it exists"""
            try:
                import requests

                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }

                # Construct the full name for the record
                record_name = f"{subdomain}.{domain}" if subdomain != '@' else domain

                url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records?name={record_name}&type=A'
                response = requests.get(url, headers=headers, timeout=10)

                if response.status_code == 200:
                    data = response.json()
                    if data.get('success') and data.get('result'):
                        return data['result'][0]  # Return first matching record
                    else:
                        return None
                else:
                    logger.error("Failed to check existing records: %s", response.status_code)
                    return None

            except Exception as e:
                logger.exception("Error checking existing DNS record: %s", e)
                return None

        def create_dns_record(self, zone_id, subdomain, ip_address, api_token, domain):
            """Create a new DNS A record"""
            try:
                import requests

                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }

                # Construct the full name for the record
                record_name = f"{subdomain}.{domain}" if subdomain != '@' else domain

                data = {
                    'type': 'A',
                    'name': record_name,
                    'content': ip_address,
                    'ttl': 300,  # 5 minutes TTL
                    'proxied': False  # Don't proxy internal services
                }

                url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records'
                response = requests.post(url, headers=headers, json=data, timeout=10)

                if response.status_code == 200:
                    result = response.json()
                    if result.get('success'):
                        return True
                    else:
                        logger.error("Failed to create DNS record: %s", result.get('errors', []))
                        return False
                else:
                    logger.error("Failed to create DNS record: %s - %s", response.status_code, response.text)
                    return False

            except Exception as e:
                logger.exception("Error creating DNS record: %s", e)
                return False

        def update_dns_record(self, zone_id, record_id, subdomain, ip_address, api_token):
            """Update an existing DNS A record"""
            try:
                import requests

                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }

                # Include the record name to avoid 9000 DNS name is invalid errors
                # Cloudflare requires 'name' when updating certain records
                data = {
                    'type': 'A',
                    'name': subdomain if subdomain != '@' else None,
                    'content': ip_address,
                    'ttl': 300,
                    'proxied': False
                }
                # Remove name if it's None to avoid sending null
                if data['name'] is None:
                    del data['name']

                url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records/{record_id}'
                response = requests.put(url, headers=headers, json=data, timeout=10)

                if response.status_code == 200:
                    result = response.json()
                    if result.get('success'):
                        return True
                    else:
                        logger.error("Failed to update DNS record: %s", result.get('errors', []))
                        return False
                else:
                    logger.error("Failed to update DNS record: %s - %s", response.status_code, response.text)
                    return False

            except Exception as e:
                logger.exception("Error updating DNS record: %s", e)
                return False

        def calculate_config_hash(self, config_data):
            """Calculate hash of tunnel configuration to detect changes"""
            config_str = yaml.dump(config_data, default_flow_style=False, sort_keys=True)
            return hashlib.md5(config_str.encode()).hexdigest()

        def update_tunnel_config(self, service_name, hostname, namespace, port):
            """Update the tunnel configuration for public services"""
            try:
                logger.info("Adding tunnel ingress rule for %s", hostname)

                # Get current config
                configmap = self.v1.read_namespaced_config_map("cloudflared-config", "cloudflare-tunnel")
                current_config = configmap.data["config.yaml"]

                # Parse the YAML config
                config_data = yaml.safe_load(current_config)

                # Desired service target for this hostname
                desired_service = f"http://{service_name}.{namespace}.svc.cluster.local:{port}"
                logger.debug("Desired service for %s: %s", hostname, desired_service)

                # Normalize hostname and check existing rules
                normalized_hostname = str(hostname).strip().lower().rstrip(".")
                logger.debug("Normalized hostname: '%s'", normalized_hostname)
                ingress_rules = config_data.get("ingress", [])
                existing_index = None
                config_changed = False
                for i, rule in enumerate(ingress_rules):
                    if not isinstance(rule, dict):
                        continue
                    current_hostname = str(rule.get("hostname", "")).strip().lower().rstrip(".")
                    logger.debug("Checking rule %s: current_hostname='%s' rule=%s", i, current_hostname, rule)
                    if current_hostname == normalized_hostname:
                        existing_index = i
                        current_service = rule.get("service")
                        logger.debug("Found existing rule at index %s, current service: '%s', desired: '%s'", i, current_service, desired_service)
                        if current_service != desired_service:
                            logger.info("Updating tunnel ingress rule for %s -> %s", hostname, desired_service)
                            rule["service"] = desired_service
                            ingress_rules[i] = rule
                            config_changed = True
                        else:
                            logger.info("Tunnel ingress rule for %s already exists", hostname)
                            return True
                        break

                # Add new rule before catch-all if not found
                if existing_index is None:
                    logger.debug("No existing rule found for %s, adding new", normalized_hostname)
                    new_rule = {
                        "hostname": hostname,
                        "service": desired_service
                    }
                    
                    # Insert before the catch-all rule
                    for i, rule in enumerate(ingress_rules):
                        if isinstance(rule, dict) and rule.get("service") == "http_status:404":
                            logger.debug("Inserting before catch-all at index %s", i)
                            ingress_rules.insert(i, new_rule)
                            config_changed = True
                            break
                    else:
                        logger.debug("Appending to end (no catch-all found)")
                        ingress_rules.append(new_rule)
                        config_changed = True

                config_data["ingress"] = ingress_rules

                # Calculate new config hash
                new_hash = self.calculate_config_hash(config_data)
                logger.debug("New config hash: %s, previous: %s", new_hash, self.tunnel_config_hash)

                # Only update if config actually changed
                if new_hash != self.tunnel_config_hash or config_changed:
                    # Update the configmap
                    updated_config = yaml.dump(config_data, default_flow_style=False)
                    configmap.data["config.yaml"] = updated_config
                    self.v1.patch_namespaced_config_map("cloudflared-config", "cloudflare-tunnel", configmap)
                    logger.info("Updated ConfigMap with new ingress rules")

                    # Force cloudflared rollout by updating pod template annotation with the new hash
                    try:
                        patch_body = {
                            "spec": {
                                "template": {
                                    "metadata": {
                                        "annotations": {
                                            "service-controller.io/config-hash": new_hash
                                        }
                                    }
                                }
                            }
                        }
                        self.apps_v1.patch_namespaced_deployment(
                            name="cloudflared",
                            namespace="cloudflare-tunnel",
                            body=patch_body
                        )
                        logger.info("Triggered cloudflared rollout due to config change")
                    except Exception as rollout_e:
                        logger.warning("Failed to trigger cloudflared rollout: %s", rollout_e)

                    # Update hash and timestamp
                    self.tunnel_config_hash = new_hash
                    self.last_config_update = time.time()

                    logger.info("Updated tunnel config for %s", hostname)
                else:
                    logger.info("Tunnel config unchanged for %s, skipping update", hostname)

                return True

            except Exception as e:
                logger.exception("Error updating tunnel config: %s", e)
                return False

        def build_desired_public_rules(self):
            """Build desired ingress rules from all public, DNS-enabled services"""
            desired = []
            services = self.get_services_with_dns_label()
            for service in services:
                try:
                    labels = (service.metadata and service.metadata.labels) or {}
                    if labels.get(DNS_ENABLED_LABEL) != "true":
                        continue
                    exposure = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)
                    if exposure != EXPOSURE_PUBLIC:
                        continue
                    hostname = labels.get(DNS_HOSTNAME_LABEL)
                    if not hostname:
                        continue
                    port = self.get_service_port(service.metadata.name, service.metadata.namespace)
                    desired_service = f"http://{service.metadata.name}.{service.metadata.namespace}.svc.cluster.local:{port}"
                    desired.append({
                        "hostname": str(hostname).strip().lower().rstrip('.'),
                        "service": desired_service,
                    })
                except Exception as e:
                    logger.debug("Error building desired rule from %s.%s: %s", service.metadata.name, service.metadata.namespace, e)
            return desired

        def get_current_public_rules(self, config_data):
            """Extract current public ingress rules from config (excluding catch-all)"""
            rules = []
            for rule in config_data.get("ingress", []) or []:
                if not isinstance(rule, dict):
                    continue
                if rule.get("service") == "http_status:404":
                    continue
                hostname = str(rule.get("hostname", "")).strip().lower().rstrip('.')
                service_target = rule.get("service")
                if hostname and service_target:
                    rules.append({"hostname": hostname, "service": service_target})
            return rules

        def reconcile_tunnel_config(self):
            """Reconcile entire set of public ingress rules. Only patch if changed."""
            try:
                # Load current configmap
                configmap = self.v1.read_namespaced_config_map("cloudflared-config", "cloudflare-tunnel")
                current_config = configmap.data["config.yaml"]
                config_data = yaml.safe_load(current_config) or {}

                desired_rules = self.build_desired_public_rules()
                current_rules = self.get_current_public_rules(config_data)

                # Sort for stable comparison
                def sort_key(r):
                    return (r.get("hostname", ""), r.get("service", ""))

                desired_sorted = sorted(desired_rules, key=sort_key)
                current_sorted = sorted(current_rules, key=sort_key)

                # Log state and differences succinctly
                desired_fmt = [f"{r['hostname']} -> {r['service']}" for r in desired_sorted]
                current_fmt = [f"{r['hostname']} -> {r['service']}" for r in current_sorted]
                logger.info("Desired rules: %s", desired_fmt)
                logger.info("Current rules: %s", current_fmt)

                if desired_sorted == current_sorted:
                    logger.info("Diff: none (no changes needed)")
                    return True

                # Compute a concise diff summary
                desired_map = {r["hostname"]: r["service"] for r in desired_sorted}
                current_map = {r["hostname"]: r["service"] for r in current_sorted}
                desired_set = {(h, s) for h, s in desired_map.items()}
                current_set = {(h, s) for h, s in current_map.items()}
                additions = sorted(list(desired_set - current_set))
                removals = sorted(list(current_set - desired_set))
                intersect_hosts = set(desired_map.keys()) & set(current_map.keys())
                changes = sorted([h for h in intersect_hosts if desired_map[h] != current_map[h]])
                logger.info("Diff: additions=%s removals=%s changes=%s", additions, removals, changes)

                logger.info("Updating rules to match desired state")
                # Rebuild ingress: keep catch-all at end
                new_ingress = []
                for r in desired_sorted:
                    new_ingress.append({"hostname": r["hostname"], "service": r["service"]})
                # Preserve catch-all 404 if present; otherwise append one
                catch_all = None
                for rule in config_data.get("ingress", []) or []:
                    if isinstance(rule, dict) and rule.get("service") == "http_status:404":
                        catch_all = rule
                        break
                if catch_all is None:
                    catch_all = {"service": "http_status:404"}
                new_ingress.append(catch_all)

                config_data["ingress"] = new_ingress

                # Patch only if hash differs
                new_hash = self.calculate_config_hash(config_data)
                if new_hash == self.tunnel_config_hash:
                    logger.info("Computed config hash unchanged; skipping patch")
                    return True

                updated_config = yaml.dump(config_data, default_flow_style=False)
                configmap.data["config.yaml"] = updated_config
                self.v1.patch_namespaced_config_map("cloudflared-config", "cloudflare-tunnel", configmap)
                logger.info("Updated ConfigMap with reconciled ingress rules")

                # Trigger rollout
                try:
                    patch_body = {
                        "spec": {
                            "template": {
                                "metadata": {
                                    "annotations": {
                                        "service-controller.io/config-hash": new_hash
                                    }
                                }
                            }
                        }
                    }
                    self.apps_v1.patch_namespaced_deployment(
                        name="cloudflared",
                        namespace="cloudflare-tunnel",
                        body=patch_body
                    )
                    logger.info("Triggered cloudflared rollout due to reconciled config change")
                except Exception as rollout_e:
                    logger.warning("Failed to trigger cloudflared rollout: %s", rollout_e)

                self.tunnel_config_hash = new_hash
                self.last_config_update = time.time()
                logger.info("Reconciled tunnel config applied")
                return True
            except Exception as e:
                logger.exception("Error reconciling tunnel config: %s", e)
                return False

        def process_service_event(self, event_type, service):
            """Process service events"""
            try:
                if not service or not service.metadata:
                    return

                service_name = service.metadata.name
                namespace = service.metadata.namespace
                labels = service.metadata.labels or {}

                # Check if DNS is enabled for this service
                if labels.get(DNS_ENABLED_LABEL) != "true":
                    return

                hostname = labels.get(DNS_HOSTNAME_LABEL)
                exposure_type = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)

                if not hostname:
                    logger.warning("Service %s.%s has DNS enabled but no hostname specified", service_name, namespace)
                    return

                logger.info("Processing %s event for %s.%s -> %s (exposure: %s)", event_type, service_name, namespace, hostname, exposure_type)

                if event_type in ["ADDED", "MODIFIED", "EXISTING"]:
                    if exposure_type == EXPOSURE_PUBLIC:
                        # Public services: ensure DNS route exists quietly; reconciliation handles config changes
                        self.create_cloudflare_dns_route(hostname)
                    elif exposure_type == EXPOSURE_INTERNAL:
                        # Internal services: ensure DNS quietly at event time
                        external_ip = self.get_ingress_external_ip()
                        if external_ip:
                            self.create_internal_dns_entry(hostname, external_ip)
                        else:
                            logger.debug("Ingress controller has no external IP/hostname yet; skip ensure for %s", hostname)
                    else:
                        logger.warning("Unknown exposure type '%s' for service %s.%s", exposure_type, service_name, namespace)

            except Exception as e:
                logger.exception("Error processing service event: %s", e)

        def reconcile_all(self):
            """Reconcile all DNS-enabled services periodically"""
            # Summary-only logs: internal DNS ensure is silent unless changes happen
            services = self.get_services_with_dns_label()
            for service in services:
                self.process_service_event("EXISTING", service)
            # Public tunnel reconciliation prints desired/current/diff summary
            self.reconcile_tunnel_config()

        def start_periodic_reconciliation(self):
            def periodic_reconcile():
                while True:
                    time.sleep(RECONCILE_INTERVAL_SEC)
                    try:
                        self.reconcile_all()
                    except Exception as e:
                        logger.exception("Error in periodic reconciliation: %s", e)
            thread = threading.Thread(target=periodic_reconcile, daemon=True)
            thread.start()
            logger.info("Started periodic reconciliation every %s seconds", RECONCILE_INTERVAL_SEC)

        def get_services_with_dns_label(self):
            """Get all services that have DNS enabled using label selector"""
            try:
                # Use label selector for efficient querying
                label_selector = f"{DNS_ENABLED_LABEL}=true"
                services = self.v1.list_service_for_all_namespaces(label_selector=label_selector)
                return services.items
            except Exception as e:
                print(f"❌ Error getting services with DNS label: {e}")
                return []

        def main(self):
            """Main controller loop"""
            try:
                logger.info("Loading Kubernetes config...")

                # Debug environment variables
                logger.debug("KUBERNETES_SERVICE_HOST: %s", os.environ.get('KUBERNETES_SERVICE_HOST', 'Not set'))
                logger.debug("KUBERNETES_SERVICE_PORT: %s", os.environ.get('KUBERNETES_SERVICE_PORT', 'Not set'))
                logger.debug("KUBECONFIG: %s", os.environ.get('KUBECONFIG', 'Not set'))

                # Load kubeconfig - try in-cluster first, then fallback to kubeconfig
                try:
                    config.load_incluster_config()
                    logger.info("Kubernetes in-cluster config loaded")
                except Exception as e:
                    logger.warning("In-cluster config failed: %s", e)
                    logger.info("Trying kubeconfig...")
                    config.load_kube_config()
                    logger.info("Kubernetes kubeconfig loaded")

                # Initialize Kubernetes clients after config is loaded
                self.v1 = client.CoreV1Api()
                self.apps_v1 = client.AppsV1Api()

                logger.info("Service Controller initialized")

                # Test Kubernetes API connection
                try:
                    logger.info("Testing Kubernetes API connection...")
                    # Try a simple API call to test connection
                    self.v1.list_namespace()
                    logger.info("Kubernetes API connection successful")
                except Exception as e:
                    logger.error("Kubernetes API connection failed: %s", e)
                    logger.info("Retrying in 10 seconds...")
                    time.sleep(10)
                    return self.main()

                # Process existing services with DNS enabled
                logger.info("Processing existing services with DNS enabled...")
                existing_services = self.get_services_with_dns_label()
                for service in existing_services:
                    self.process_service_event("EXISTING", service)

                # Start periodic reconciliation thread
                self.start_periodic_reconciliation()

                # Watch for changes using label selector for efficiency
                logger.info("Watching for service changes with DNS enabled...")
                w = watch.Watch()

                # Watch only services with DNS enabled label
                label_selector = f"{DNS_ENABLED_LABEL}=true"
                try:
                    for event in w.stream(self.v1.list_service_for_all_namespaces, label_selector=label_selector):
                        self.process_service_event(event["type"], event["object"])
                except Exception as e:
                    logger.error("Watch stream error: %s", e)
                    logger.info("Restarting watch in 5 seconds...")
                    time.sleep(5)
                    return self.main()

            except Exception as e:
                logger.exception("Controller error: %s", e)
                time.sleep(10)
                self.main()

    if __name__ == "__main__":
        controller = ServiceController()
        controller.main()
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: service-controller
rules:
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "patch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: service-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: service-controller
subjects:
  - kind: ServiceAccount
    name: service-controller
    namespace: cloudflare-tunnel
