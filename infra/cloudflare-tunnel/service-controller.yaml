apiVersion: apps/v1
kind: Deployment
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
  labels:
    app: service-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: service-controller
  template:
    metadata:
      labels:
        app: service-controller
    spec:
      serviceAccountName: service-controller
      containers:
        - name: service-controller
          image: python:3.13-alpine
          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "üîç Installing dependencies..."
              apk add --no-cache curl
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              mv kubectl /usr/local/bin/
              pip install kubernetes pyyaml cloudflare --quiet

              echo "üîç Starting Service Controller..."
              python -u /app/controller.py
          env:
            - name: CLOUDFLARE_API_TOKEN
              valueFrom:
                secretKeyRef:
                  name: cloudflare-api-token
                  key: token
            - name: INGRESS_NAMESPACE
              value: ingress-nginx
            - name: INGRESS_SERVICE_NAME
              value: ingress-nginx-controller
          volumeMounts:
            - name: controller-script
              mountPath: /app
          resources:
            limits:
              memory: 256Mi
              cpu: 200m
            requests:
              memory: 128Mi
              cpu: 100m
      volumes:
        - name: controller-script
          configMap:
            name: service-controller-script
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: service-controller-script
  namespace: cloudflare-tunnel
data:
  controller.py: |-
    #!/usr/bin/env python3

    import os
    import time
    import yaml
    import subprocess
    import hashlib
    import logging
    import re
    from kubernetes import client, config, watch
    import threading
    from cloudflare import Cloudflare

    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO').upper()
    logging.basicConfig(level=LOG_LEVEL, format="%(asctime)s %(levelname)s %(name)s %(message)s")
    logger = logging.getLogger("service-controller")
    RECONCILE_INTERVAL_SEC = int(os.environ.get('RECONCILE_INTERVAL_SEC', '300'))

    # Label constants
    DNS_ENABLED_LABEL = "dns.service-controller.io/enabled"
    DNS_HOSTNAME_LABEL = "dns.service-controller.io/hostname"
    EXPOSURE_TYPE_LABEL = "exposure.service-controller.io/type"  # "public" or "internal"

    # Exposure types
    EXPOSURE_PUBLIC = "public"
    EXPOSURE_INTERNAL = "internal"

    class ServiceController:
        def __init__(self):
            self.v1 = None
            self.apps_v1 = None
            self.tunnel_config_hash = None
            self.last_config_update = 0
            # Ingress settings for internal services
            self.ingress_namespace = os.environ.get('INGRESS_NAMESPACE', 'ingress-nginx')
            self.ingress_service_name = os.environ.get('INGRESS_SERVICE_NAME', 'ingress-nginx-controller')
            # Cloudflare client cache
            self.cf = None

        def ensure_cf_client(self):
            """Initialize Cloudflare client if not already created."""
            if self.cf is not None:
                return self.cf
            api_token = os.environ.get('CLOUDFLARE_API_TOKEN')
            if not api_token:
                raise RuntimeError("CLOUDFLARE_API_TOKEN is not set")
            self.cf = Cloudflare(api_token=api_token)
            return self.cf

        def get_service_port(self, service_name, namespace):
            """Get the port of a service"""
            try:
                service = self.v1.read_namespaced_service(service_name, namespace)
                if service.spec.ports:
                    return service.spec.ports[0].port
                return 80
            except Exception as e:
                logger.warning("Error getting port for %s.%s: %s", service_name, namespace, e)
                return 80

        def get_ingress_external_ip(self):
            """Get the external IP of the ingress controller service for internal HTTPS"""
            try:
                service = self.v1.read_namespaced_service(self.ingress_service_name, self.ingress_namespace)
                if service.status.load_balancer and service.status.load_balancer.ingress:
                    ip = service.status.load_balancer.ingress[0].ip
                    if ip:
                        return ip
                return None
            except Exception as e:
                logger.warning("Error getting external IP for ingress %s.%s: %s", self.ingress_service_name, self.ingress_namespace, e)
                return None

        def create_cloudflare_dns_route(self, hostname):
            """Create DNS route using cloudflared for public services"""
            try:
                # Skip creating if route already exists
                if self.public_route_exists(hostname):
                    logger.debug("Cloudflare DNS route already exists for %s", hostname)
                    return True

                logger.debug("Ensuring Cloudflare DNS route for %s", hostname)

                cmd = [
                    'kubectl', 'exec', '-n', 'cloudflare-tunnel',
                    'deployment/cloudflared', '--', 'cloudflared',
                    'tunnel', 'route', 'dns', '--overwrite-dns',
                    'homelab-tunnel', hostname
                ]
                result = subprocess.run(cmd, capture_output=True, text=True)
                out = (result.stdout or "") + "\n" + (result.stderr or "")
                logger.debug("DNS route cmd rc=%s out='%s'", result.returncode, out.strip())
                if result.returncode == 0:
                    # Heuristics: avoid noisy info logs; treat as ensure at debug level
                    if re.search(r"exist|already", out, re.IGNORECASE):
                        logger.debug("Cloudflare DNS route already existed for %s", hostname)
                    else:
                        logger.debug("Ensured Cloudflare DNS route for %s", hostname)
                    return True
                else:
                    logger.warning("Cloudflare DNS route creation failed for %s: %s", hostname, result.stderr.strip())
                    # Try without overwrite flag as fallback
                    cmd_fallback = [
                        'kubectl', 'exec', '-n', 'cloudflare-tunnel',
                        'deployment/cloudflared', '--', 'cloudflared',
                        'tunnel', 'route', 'dns',
                        'homelab-tunnel', hostname
                    ]
                    result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)
                    fb_out = (result_fallback.stdout or "") + "\n" + (result_fallback.stderr or "")
                    logger.debug("Fallback DNS route rc=%s out='%s'", result_fallback.returncode, fb_out.strip())
                    if result_fallback.returncode == 0:
                        if re.search(r"exist|already", fb_out, re.IGNORECASE):
                            logger.debug("Cloudflare DNS route already existed for %s (fallback)", hostname)
                        else:
                            logger.debug("Ensured Cloudflare DNS route for %s (fallback)", hostname)
                        return True
                    else:
                        logger.error("Failed to create Cloudflare DNS route for %s: %s", hostname, result_fallback.stderr.strip())
                        return False
            except subprocess.TimeoutExpired:
                logger.warning("DNS route command timed out for %s", hostname)
                return False
            except Exception as e:
                logger.exception("Error creating Cloudflare DNS route for %s: %s", hostname, e)
                return False

        def public_route_exists(self, hostname):
            """Check if a Cloudflare DNS route already exists for the hostname"""
            try:
                cmd = [
                    'kubectl', 'exec', '-n', 'cloudflare-tunnel',
                    'deployment/cloudflared', '--', 'cloudflared',
                    'tunnel', 'route', 'dns', 'homelab-tunnel', 'list'
                ]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                if result.returncode != 0:
                    logger.debug("route list failed rc=%s stderr='%s'", result.returncode, result.stderr.strip())
                    return False
                out = result.stdout or ""
                # Simple containment check; output is tabular, so contains hostname when present
                exists = hostname in out
                logger.debug("route exists for %s: %s", hostname, exists)
                return exists
            except subprocess.TimeoutExpired:
                logger.warning("Timeout checking route existence for %s", hostname)
                return False
            except Exception as e:
                logger.debug("Error checking route existence for %s: %s", hostname, e)
                return False

        def create_internal_dns_entry(self, hostname, ip_address):
            """Ensure internal DNS entry using MetalLB IP via Cloudflare API"""
            try:
                logger.debug("Ensuring internal DNS entry for %s -> %s", hostname, ip_address)

                # Get Cloudflare API credentials from environment or secret
                api_token = os.environ.get('CLOUDFLARE_API_TOKEN')
                if not api_token:
                    logger.warning("CLOUDFLARE_API_TOKEN not found in environment variables")
                    return False

                # Extract domain from hostname (e.g., "service.internal.example.com" -> "example.com")
                domain_parts = hostname.split('.')
                if len(domain_parts) < 2:
                    print(f"‚ö†Ô∏è  Invalid hostname format: {hostname}")
                    return False

                # Get domain (last two parts: example.com)
                domain = '.'.join(domain_parts[-2:])
                subdomain = '.'.join(domain_parts[:-2]) if len(domain_parts) > 2 else '@'

                logger.debug("Domain: %s, Subdomain: %s", domain, subdomain)

                # Get zone ID for the domain
                zone_id = self.get_cloudflare_zone_id(domain, api_token)
                if not zone_id:
                    logger.error("Could not find zone ID for domain: %s", domain)
                    return False

                # Check if record already exists
                existing_record = self.get_existing_dns_record(zone_id, subdomain, domain, api_token)

                if existing_record:
                    # Update existing record if IP is different
                    if existing_record.get('content') != ip_address:
                        logger.info("Updating internal DNS record for %s -> %s", hostname, ip_address)
                        success = self.update_dns_record(zone_id, existing_record['id'], subdomain, ip_address, api_token)
                        return success
                    else:
                        logger.debug("Internal DNS record for %s already correct", hostname)
                        return True
                else:
                    # Create new record
                    logger.info("Creating internal DNS record for %s -> %s", hostname, ip_address)
                    success = self.create_dns_record(zone_id, subdomain, ip_address, api_token, domain)
                    return success

            except Exception as e:
                logger.exception("Error creating internal DNS entry for %s: %s", hostname, e)
                return False

        def get_cloudflare_zone_id(self, domain, api_token):
            """Get Cloudflare zone ID for a domain using SDK"""
            try:
                cf = self.ensure_cf_client()
                zones = cf.zones.list(name=domain)
                first_zone = None
                for z in zones:
                    first_zone = z
                    break
                if first_zone is not None:
                    zone_id = getattr(first_zone, 'id', None)
                    if zone_id is None and isinstance(first_zone, dict):
                        zone_id = first_zone.get('id')
                    if zone_id:
                        logger.debug("Found zone ID for %s: %s", domain, zone_id)
                        return zone_id
                logger.error("No zone found for domain: %s", domain)
                return None
            except Exception as e:
                logger.exception("Error getting zone ID via SDK: %s", e)
                return None

        def get_existing_dns_record(self, zone_id, subdomain, domain, api_token):
            """Get existing DNS A record if it exists using SDK"""
            try:
                cf = self.ensure_cf_client()
                record_name = f"{subdomain}.{domain}" if subdomain != '@' else domain
                records = cf.dns.records.list(zone_id=zone_id, name=record_name, type='A')
                first_rec = None
                for r in records:
                    first_rec = r
                    break
                if first_rec is not None:
                    # Normalize minimal fields used by callers
                    rec_id = getattr(first_rec, 'id', None)
                    rec_content = getattr(first_rec, 'content', None)
                    rec_name = getattr(first_rec, 'name', None)
                    if isinstance(first_rec, dict):
                        rec_id = rec_id or first_rec.get('id')
                        rec_content = rec_content or first_rec.get('content')
                        rec_name = rec_name or first_rec.get('name')
                    return {'id': rec_id, 'content': rec_content, 'name': rec_name}
                return None
            except Exception as e:
                logger.exception("Error checking existing DNS record via SDK: %s", e)
                return None

        def get_cloudflare_records_by_names(self, zone_id, api_token, names):
            """Fetch A records for provided FQDN names using SDK. Return map name->{ip,id}."""
            results = {}
            try:
                cf = self.ensure_cf_client()
                for n in names:
                    recs = cf.dns.records.list(zone_id=zone_id, name=n, type='A')
                    first = None
                    for r in recs:
                        first = r
                        break
                    if first is not None:
                        name_val = getattr(first, 'name', None)
                        content_val = getattr(first, 'content', None)
                        id_val = getattr(first, 'id', None)
                        if isinstance(first, dict):
                            name_val = name_val or first.get('name')
                            content_val = content_val or first.get('content')
                            id_val = id_val or first.get('id')
                        key = (name_val or '').lower().rstrip('.')
                        results[key] = {'ip': content_val, 'id': id_val}
            except Exception as e:
                logger.exception("Error fetching DNS records by names via SDK: %s", e)
            return results

        def create_dns_record(self, zone_id, subdomain, ip_address, api_token, domain):
            """Create a new DNS A record using SDK. Proactively replace conflicting CNAME."""
            try:
                record_name = f"{subdomain}.{domain}" if subdomain != '@' else domain
                cf = self.ensure_cf_client()

                # Proactively delete conflicting CNAME if present
                cname_records = cf.dns.records.list(zone_id=zone_id, name=record_name, type='CNAME')
                if cname_records:
                    rec = cname_records[0]
                    rec_id = rec.id if hasattr(rec, 'id') else rec.get('id')
                    if rec_id:
                        cf.dns.records.delete(zone_id=zone_id, dns_record_id=rec_id)
                        logger.info("Deleted conflicting CNAME for %s", record_name)

                cf.dns.records.create(
                    zone_id=zone_id,
                    type='A',
                    name=record_name,
                    content=ip_address,
                    ttl=300,
                    proxied=False
                )
                return True
            except Exception as e:
                # Keep a helpful message if CNAME conflict arises due to race
                msg = str(e).lower()
                if ('81054' in msg or 'cname' in msg) and 'cf' in locals():
                    try:
                        cname_records = cf.dns.records.list(zone_id=zone_id, name=record_name, type='CNAME')
                        first_cname = None
                        for r in cname_records:
                            first_cname = r
                            break
                        if first_cname is not None:
                            rec_id = getattr(first_cname, 'id', None)
                            if rec_id is None and isinstance(first_cname, dict):
                                rec_id = first_cname.get('id')
                            if rec_id:
                                cf.dns.records.delete(zone_id=zone_id, dns_record_id=rec_id)
                                cf.dns.records.create(
                                    zone_id=zone_id,
                                    type='A',
                                    name=record_name,
                                    content=ip_address,
                                    ttl=300,
                                    proxied=False
                                )
                                return True
                    except Exception as e2:
                        logger.exception("Retry after CNAME deletion failed: %s", e2)
                logger.exception("Error creating DNS record via SDK: %s", e)
                return False

        def update_dns_record(self, zone_id, record_id, subdomain, ip_address, api_token):
            """Update an existing DNS A record using SDK"""
            try:
                cf = self.ensure_cf_client()
                name_value = subdomain if subdomain != '@' else None
                update_payload = {
                    'type': 'A',
                    'content': ip_address,
                    'ttl': 300,
                    'proxied': False
                }
                if name_value:
                    update_payload['name'] = name_value
                cf.dns.records.update(zone_id=zone_id, dns_record_id=record_id, **update_payload)
                return True
            except Exception as e:
                logger.exception("Error updating DNS record via SDK: %s", e)
                return False

        def find_dns_record_by_name_and_type(self, zone_id, record_name, record_type, api_token):
            """Find a DNS record by exact name and type using SDK. Returns dict or None."""
            try:
                cf = self.ensure_cf_client()
                recs = cf.dns.records.list(zone_id=zone_id, name=record_name, type=record_type)
                first = None
                for r in recs:
                    first = r
                    break
                if first is not None:
                    # Normalize to dict
                    rec_id = getattr(first, 'id', None)
                    rec_name = getattr(first, 'name', None)
                    rec_type = getattr(first, 'type', None)
                    rec_content = getattr(first, 'content', None)
                    if isinstance(first, dict):
                        rec_id = rec_id or first.get('id')
                        rec_name = rec_name or first.get('name')
                        rec_type = rec_type or first.get('type')
                        rec_content = rec_content or first.get('content')
                    return {'id': rec_id, 'name': rec_name, 'type': rec_type, 'content': rec_content}
                return None
            except Exception as e:
                logger.exception("Error finding DNS record by name/type via SDK: %s", e)
                return None

        def delete_dns_record(self, zone_id, record_id, api_token):
            """Delete a DNS record by id using SDK. Returns True on success."""
            try:
                cf = self.ensure_cf_client()
                cf.dns.records.delete(zone_id=zone_id, dns_record_id=record_id)
                logger.info("Deleted DNS record id=%s", record_id)
                return True
            except Exception as e:
                logger.exception("Error deleting DNS record via SDK id=%s: %s", record_id, e)
                return False

        def calculate_config_hash(self, config_data):
            """Calculate hash of tunnel configuration to detect changes"""
            config_str = yaml.dump(config_data, default_flow_style=False, sort_keys=True)
            return hashlib.md5(config_str.encode()).hexdigest()

        def update_tunnel_config(self, service_name, hostname, namespace, port):
            """Update the tunnel configuration for public services"""
            try:
                logger.info("Adding tunnel ingress rule for %s", hostname)

                # Get current config
                configmap = self.v1.read_namespaced_config_map("cloudflared-config", "cloudflare-tunnel")
                current_config = configmap.data["config.yaml"]

                # Parse the YAML config
                config_data = yaml.safe_load(current_config)

                # Desired service target for this hostname
                desired_service = f"http://{service_name}.{namespace}.svc.cluster.local:{port}"
                logger.debug("Desired service for %s: %s", hostname, desired_service)

                # Normalize hostname and check existing rules
                normalized_hostname = str(hostname).strip().lower().rstrip(".")
                logger.debug("Normalized hostname: '%s'", normalized_hostname)
                ingress_rules = config_data.get("ingress", [])
                existing_index = None
                config_changed = False
                for i, rule in enumerate(ingress_rules):
                    if not isinstance(rule, dict):
                        continue
                    current_hostname = str(rule.get("hostname", "")).strip().lower().rstrip(".")
                    logger.debug("Checking rule %s: current_hostname='%s' rule=%s", i, current_hostname, rule)
                    if current_hostname == normalized_hostname:
                        existing_index = i
                        current_service = rule.get("service")
                        logger.debug("Found existing rule at index %s, current service: '%s', desired: '%s'", i, current_service, desired_service)
                        if current_service != desired_service:
                            logger.info("Updating tunnel ingress rule for %s -> %s", hostname, desired_service)
                            rule["service"] = desired_service
                            ingress_rules[i] = rule
                            config_changed = True
                        else:
                            logger.info("Tunnel ingress rule for %s already exists", hostname)
                            return True
                        break

                # Add new rule before catch-all if not found
                if existing_index is None:
                    logger.debug("No existing rule found for %s, adding new", normalized_hostname)
                    new_rule = {
                        "hostname": hostname,
                        "service": desired_service
                    }
                    
                    # Insert before the catch-all rule
                    for i, rule in enumerate(ingress_rules):
                        if isinstance(rule, dict) and rule.get("service") == "http_status:404":
                            logger.debug("Inserting before catch-all at index %s", i)
                            ingress_rules.insert(i, new_rule)
                            config_changed = True
                            break
                    else:
                        logger.debug("Appending to end (no catch-all found)")
                        ingress_rules.append(new_rule)
                        config_changed = True

                config_data["ingress"] = ingress_rules

                # Calculate new config hash
                new_hash = self.calculate_config_hash(config_data)
                logger.debug("New config hash: %s, previous: %s", new_hash, self.tunnel_config_hash)

                # Only update if config actually changed
                if new_hash != self.tunnel_config_hash or config_changed:
                    # Update the configmap
                    updated_config = yaml.dump(config_data, default_flow_style=False)
                    configmap.data["config.yaml"] = updated_config
                    self.v1.patch_namespaced_config_map("cloudflared-config", "cloudflare-tunnel", configmap)
                    logger.info("Updated ConfigMap with new ingress rules")

                    # Force cloudflared rollout by updating pod template annotation with the new hash
                    try:
                        patch_body = {
                            "spec": {
                                "template": {
                                    "metadata": {
                                        "annotations": {
                                            "service-controller.io/config-hash": new_hash
                                        }
                                    }
                                }
                            }
                        }
                        self.apps_v1.patch_namespaced_deployment(
                            name="cloudflared",
                            namespace="cloudflare-tunnel",
                            body=patch_body
                        )
                        logger.info("Triggered cloudflared rollout due to config change")
                    except Exception as rollout_e:
                        logger.warning("Failed to trigger cloudflared rollout: %s", rollout_e)

                    # Update hash and timestamp
                    self.tunnel_config_hash = new_hash
                    self.last_config_update = time.time()

                    logger.info("Updated tunnel config for %s", hostname)
                else:
                    logger.info("Tunnel config unchanged for %s, skipping update", hostname)

                return True

            except Exception as e:
                logger.exception("Error updating tunnel config: %s", e)
                return False

        def build_desired_public_rules(self):
            """Build desired ingress rules from all public, DNS-enabled services"""
            desired = []
            services = self.get_services_with_dns_label()
            for service in services:
                try:
                    labels = (service.metadata and service.metadata.labels) or {}
                    if labels.get(DNS_ENABLED_LABEL) != "true":
                        continue
                    exposure = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)
                    if exposure != EXPOSURE_PUBLIC:
                        continue
                    hostname = labels.get(DNS_HOSTNAME_LABEL)
                    if not hostname:
                        continue
                    port = self.get_service_port(service.metadata.name, service.metadata.namespace)
                    desired_service = f"http://{service.metadata.name}.{service.metadata.namespace}.svc.cluster.local:{port}"
                    desired.append({
                        "hostname": str(hostname).strip().lower().rstrip('.'),
                        "service": desired_service,
                    })
                except Exception as e:
                    logger.debug("Error building desired rule from %s.%s: %s", service.metadata.name, service.metadata.namespace, e)
            return desired

        def get_current_public_rules(self, config_data):
            """Extract current public ingress rules from config (excluding catch-all)"""
            rules = []
            for rule in config_data.get("ingress", []) or []:
                if not isinstance(rule, dict):
                    continue
                if rule.get("service") == "http_status:404":
                    continue
                hostname = str(rule.get("hostname", "")).strip().lower().rstrip('.')
                service_target = rule.get("service")
                if hostname and service_target:
                    rules.append({"hostname": hostname, "service": service_target})
            return rules

        def reconcile_tunnel_config(self):
            """Reconcile entire set of public ingress rules. Only patch if changed."""
            try:
                # Load current configmap
                configmap = self.v1.read_namespaced_config_map("cloudflared-config", "cloudflare-tunnel")
                current_config = configmap.data["config.yaml"]
                config_data = yaml.safe_load(current_config) or {}

                # Capture the existing hash BEFORE any mutation so we compare against
                # the actual current state rather than a cached internal hash.
                existing_hash = self.calculate_config_hash(config_data)

                desired_rules = self.build_desired_public_rules()
                current_rules = self.get_current_public_rules(config_data)

                # Sort for stable comparison
                def sort_key(r):
                    return (r.get("hostname", ""), r.get("service", ""))

                desired_sorted = sorted(desired_rules, key=sort_key)
                current_sorted = sorted(current_rules, key=sort_key)

                # Log state and differences succinctly
                desired_fmt = [f"{r['hostname']} -> {r['service']}" for r in desired_sorted]
                current_fmt = [f"{r['hostname']} -> {r['service']}" for r in current_sorted]
                logger.info("Desired rules: %s", desired_fmt)
                logger.info("Current rules: %s", current_fmt)

                if desired_sorted == current_sorted:
                    logger.info("Diff: none (no changes needed)")
                    return True

                # Compute a concise diff summary
                desired_map = {r["hostname"]: r["service"] for r in desired_sorted}
                current_map = {r["hostname"]: r["service"] for r in current_sorted}
                desired_set = {(h, s) for h, s in desired_map.items()}
                current_set = {(h, s) for h, s in current_map.items()}
                additions = sorted(list(desired_set - current_set))
                removals = sorted(list(current_set - desired_set))
                intersect_hosts = set(desired_map.keys()) & set(current_map.keys())
                changes = sorted([h for h in intersect_hosts if desired_map[h] != current_map[h]])
                logger.info("Diff: additions=%s removals=%s changes=%s", additions, removals, changes)

                logger.info("Updating rules to match desired state")
                # Rebuild ingress: keep catch-all at end
                new_ingress = []
                for r in desired_sorted:
                    new_ingress.append({"hostname": r["hostname"], "service": r["service"]})
                # Preserve catch-all 404 if present; otherwise append one
                catch_all = None
                for rule in config_data.get("ingress", []) or []:
                    if isinstance(rule, dict) and rule.get("service") == "http_status:404":
                        catch_all = rule
                        break
                if catch_all is None:
                    catch_all = {"service": "http_status:404"}
                new_ingress.append(catch_all)

                config_data["ingress"] = new_ingress

                # Patch only if the new config differs from what is currently stored
                new_hash = self.calculate_config_hash(config_data)
                if new_hash == existing_hash:
                    logger.info("Reconciled config equals current ConfigMap; skipping patch")
                    return True

                updated_config = yaml.dump(config_data, default_flow_style=False)
                configmap.data["config.yaml"] = updated_config
                self.v1.patch_namespaced_config_map("cloudflared-config", "cloudflare-tunnel", configmap)
                logger.info("Updated ConfigMap with reconciled ingress rules")

                # Trigger rollout
                try:
                    patch_body = {
                        "spec": {
                            "template": {
                                "metadata": {
                                    "annotations": {
                                        "service-controller.io/config-hash": new_hash
                                    }
                                }
                            }
                        }
                    }
                    self.apps_v1.patch_namespaced_deployment(
                        name="cloudflared",
                        namespace="cloudflare-tunnel",
                        body=patch_body
                    )
                    logger.info("Triggered cloudflared rollout due to reconciled config change")
                except Exception as rollout_e:
                    logger.warning("Failed to trigger cloudflared rollout: %s", rollout_e)

                self.tunnel_config_hash = new_hash
                self.last_config_update = time.time()
                logger.info("Reconciled tunnel config applied")
                return True
            except Exception as e:
                logger.exception("Error reconciling tunnel config: %s", e)
                return False

        def reconcile_internal_dns(self):
            """Reconcile internal DNS A records for all internal, DNS-enabled services.
            Only log summaries and update when diffs exist."""
            try:
                services = self.get_services_with_dns_label()
                hostnames = []
                for service in services:
                    labels = (service.metadata and service.metadata.labels) or {}
                    if labels.get(DNS_ENABLED_LABEL) != "true":
                        continue
                    if labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC) != EXPOSURE_INTERNAL:
                        continue
                    hostname = labels.get(DNS_HOSTNAME_LABEL)
                    if hostname:
                        hostnames.append(hostname)

                if not hostnames:
                    logger.debug("No internal services to reconcile")
                    return True

                external_ip = self.get_ingress_external_ip()
                if not external_ip:
                    logger.debug("No ingress IP available; skipping internal DNS reconcile")
                    return True

                # Assume all internal hostnames share the same zone (domain is last 2 parts)
                domain = '.'.join(hostnames[0].split('.')[-2:])
                names = [h.lower().rstrip('.') for h in hostnames]

                api_token = os.environ.get('CLOUDFLARE_API_TOKEN')
                if not api_token:
                    logger.debug("No CLOUDFLARE_API_TOKEN; skipping internal DNS reconcile")
                    return True

                zone_id = self.get_cloudflare_zone_id(domain, api_token)
                if not zone_id:
                    logger.debug("No zone ID for domain %s; skipping internal DNS reconcile", domain)
                    return True

                current = self.get_cloudflare_records_by_names(zone_id, api_token, names)

                desired_map = {n: external_ip for n in names}
                current_map = {n: info.get('ip') for n, info in current.items()}

                desired_fmt = [f"{n} -> {ip}" for n, ip in sorted(desired_map.items())]
                current_fmt = [f"{n} -> {ip}" for n, ip in sorted(current_map.items())]
                logger.info("Desired internal DNS: %s", desired_fmt)
                logger.info("Current internal DNS: %s", current_fmt)

                additions = sorted([n for n in names if n not in current_map])
                changes = sorted([n for n in names if current_map.get(n) and current_map[n] != external_ip])
                removals = []  # We do not remove stray records here

                if not additions and not changes and not removals:
                    logger.info("Internal DNS diff: none (no changes needed)")
                    return True

                logger.info("Internal DNS diff: additions=%s changes=%s removals=%s", additions, changes, removals)
                logger.info("Updating internal DNS records to match desired state")

                # Apply upserts
                for n in additions:
                    sub = n.replace(f".{domain}", "") if n.endswith(f".{domain}") else n
                    self.create_dns_record(zone_id, sub, external_ip, api_token, domain)
                for n in changes:
                    sub = n.replace(f".{domain}", "") if n.endswith(f".{domain}") else n
                    rec = current.get(n)
                    if rec and rec.get('id'):
                        self.update_dns_record(zone_id, rec['id'], sub, external_ip, api_token)

                logger.info("Internal DNS reconcile complete")
                return True
            except Exception as e:
                logger.exception("Error reconciling internal DNS: %s", e)
                return False

        def process_service_event(self, event_type, service):
            """Process service events"""
            try:
                if not service or not service.metadata:
                    return

                service_name = service.metadata.name
                namespace = service.metadata.namespace
                labels = service.metadata.labels or {}

                # Check if DNS is enabled for this service
                if labels.get(DNS_ENABLED_LABEL) != "true":
                    return

                hostname = labels.get(DNS_HOSTNAME_LABEL)
                exposure_type = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)

                if not hostname:
                    logger.warning("Service %s.%s has DNS enabled but no hostname specified", service_name, namespace)
                    return

                logger.info("Processing %s event for %s.%s -> %s (exposure: %s)", event_type, service_name, namespace, hostname, exposure_type)

                if event_type in ["ADDED", "MODIFIED", "EXISTING"]:
                    if exposure_type == EXPOSURE_PUBLIC:
                        # Public services: ensure DNS route exists quietly; reconciliation handles config changes
                        self.create_cloudflare_dns_route(hostname)
                    elif exposure_type == EXPOSURE_INTERNAL:
                        # Internal services: ensure DNS quietly at event time
                        external_ip = self.get_ingress_external_ip()
                        if external_ip:
                            self.create_internal_dns_entry(hostname, external_ip)
                        else:
                            logger.debug("Ingress controller has no external IP/hostname yet; skip ensure for %s", hostname)
                    else:
                        logger.warning("Unknown exposure type '%s' for service %s.%s", exposure_type, service_name, namespace)

            except Exception as e:
                logger.exception("Error processing service event: %s", e)

        def reconcile_all(self):
            """Reconcile all DNS-enabled services periodically"""
            # Summary-only reconciles: compute diffs and apply if needed
            self.reconcile_internal_dns()
            self.reconcile_tunnel_config()

        def start_periodic_reconciliation(self):
            def periodic_reconcile():
                while True:
                    time.sleep(RECONCILE_INTERVAL_SEC)
                    try:
                        self.reconcile_all()
                    except Exception as e:
                        logger.exception("Error in periodic reconciliation: %s", e)
            thread = threading.Thread(target=periodic_reconcile, daemon=True)
            thread.start()
            logger.info("Started periodic reconciliation every %s seconds", RECONCILE_INTERVAL_SEC)

        def get_services_with_dns_label(self):
            """Get all services that have DNS enabled using label selector"""
            try:
                # Use label selector for efficient querying
                label_selector = f"{DNS_ENABLED_LABEL}=true"
                services = self.v1.list_service_for_all_namespaces(label_selector=label_selector)
                return services.items
            except Exception as e:
                print(f"‚ùå Error getting services with DNS label: {e}")
                return []

        def main(self):
            """Main controller loop"""
            try:
                logger.info("Loading Kubernetes config...")

                # Debug environment variables
                logger.debug("KUBERNETES_SERVICE_HOST: %s", os.environ.get('KUBERNETES_SERVICE_HOST', 'Not set'))
                logger.debug("KUBERNETES_SERVICE_PORT: %s", os.environ.get('KUBERNETES_SERVICE_PORT', 'Not set'))
                logger.debug("KUBECONFIG: %s", os.environ.get('KUBECONFIG', 'Not set'))

                # Load kubeconfig - try in-cluster first, then fallback to kubeconfig
                try:
                    config.load_incluster_config()
                    logger.info("Kubernetes in-cluster config loaded")
                except Exception as e:
                    logger.warning("In-cluster config failed: %s", e)
                    logger.info("Trying kubeconfig...")
                    config.load_kube_config()
                    logger.info("Kubernetes kubeconfig loaded")

                # Initialize Kubernetes clients after config is loaded
                self.v1 = client.CoreV1Api()
                self.apps_v1 = client.AppsV1Api()

                logger.info("Service Controller initialized")

                # Test Kubernetes API connection
                try:
                    logger.info("Testing Kubernetes API connection...")
                    # Try a simple API call to test connection
                    self.v1.list_namespace()
                    logger.info("Kubernetes API connection successful")
                except Exception as e:
                    logger.error("Kubernetes API connection failed: %s", e)
                    logger.info("Retrying in 10 seconds...")
                    time.sleep(10)
                    return self.main()

                # Initial full reconcile
                logger.info("Performing initial full reconciliation...")
                self.reconcile_all()

                # Start periodic reconciliation thread
                self.start_periodic_reconciliation()

                # Watch for changes using label selector for efficiency
                logger.info("Watching for service changes with DNS enabled...")
                w = watch.Watch()

                # Watch only services with DNS enabled label
                label_selector = f"{DNS_ENABLED_LABEL}=true"
                try:
                    for event in w.stream(self.v1.list_service_for_all_namespaces, label_selector=label_selector):
                        self.process_service_event(event["type"], event["object"])
                except Exception as e:
                    logger.error("Watch stream error: %s", e)
                    logger.info("Restarting watch in 5 seconds...")
                    time.sleep(5)
                    return self.main()

            except Exception as e:
                logger.exception("Controller error: %s", e)
                time.sleep(10)
                self.main()

    if __name__ == "__main__":
        controller = ServiceController()
        controller.main()
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: service-controller
rules:
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "patch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: service-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: service-controller
subjects:
  - kind: ServiceAccount
    name: service-controller
    namespace: cloudflare-tunnel
