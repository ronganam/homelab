apiVersion: apps/v1
kind: Deployment
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
  labels:
    app: service-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: service-controller
  template:
    metadata:
      labels:
        app: service-controller
    spec:
      serviceAccountName: service-controller
      containers:
        - name: service-controller
          image: python:3.13-alpine
          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "üîç Installing dependencies..."
              apk add --no-cache curl
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              mv kubectl /usr/local/bin/
              pip install kubernetes pyyaml requests --quiet

              echo "üîç Starting Service Controller..."
              python -u /app/controller.py
          env:
            - name: CLOUDFLARE_API_TOKEN
              valueFrom:
                secretKeyRef:
                  name: cloudflare-api-token
                  key: token
            - name: INGRESS_NAMESPACE
              value: ingress-nginx
            - name: INGRESS_SERVICE_NAME
              value: ingress-nginx-controller
          volumeMounts:
            - name: controller-script
              mountPath: /app
          resources:
            limits:
              memory: 256Mi
              cpu: 200m
            requests:
              memory: 128Mi
              cpu: 100m
      volumes:
        - name: controller-script
          configMap:
            name: service-controller-script
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: service-controller-script
  namespace: cloudflare-tunnel
data:
  controller.py: "#!/usr/bin/env python3\n\nimport os\nimport time\nimport yaml\nimport json\nimport subprocess\nimport hashlib\nfrom kubernetes import client, config, watch\n\n# Label constants\nDNS_ENABLED_LABEL = \"dns.service-controller.io/enabled\"\nDNS_HOSTNAME_LABEL = \"dns.service-controller.io/hostname\"\nEXPOSURE_TYPE_LABEL = \"exposure.service-controller.io/type\"  # \"public\" or \"internal\"\n\n# Exposure types\nEXPOSURE_PUBLIC = \"public\"\nEXPOSURE_INTERNAL = \"internal\"\n\nclass ServiceController:\n    def __init__(self):\n        self.v1 = None\n        self.apps_v1 = None\n        self.tunnel_config_hash = None\n        self.last_config_update = 0\n        # Ingress settings for internal services\n        self.ingress_namespace = os.environ.get('INGRESS_NAMESPACE', 'ingress-nginx')\n        self.ingress_service_name = os.environ.get('INGRESS_SERVICE_NAME', 'ingress-nginx-controller')\n        \n    def get_service_port(self, service_name, namespace):\n        \"\"\"Get the port of a service\"\"\"\n        try:\n            service = self.v1.read_namespaced_service(service_name, namespace)\n            if service.spec.ports:\n                return service.spec.ports[0].port\n            return 80\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Error getting port for {service_name}.{namespace}: {e}\")\n            return 80\n    \n    def get_service_external_ip(self, service_name, namespace):\n        \"\"\"Get the external IP of a service (for MetalLB)\"\"\"\n        try:\n            service = self.v1.read_namespaced_service(service_name, namespace)\n            if service.status.load_balancer and service.status.load_balancer.ingress:\n                return service.status.load_balancer.ingress[0].ip\n            return None\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Error getting external IP for {service_name}.{namespace}: {e}\")\n            return None\n\n    def get_ingress_external_ip(self):\n        \"\"\"Get the external IP of the ingress controller service for internal HTTPS\"\"\"\n        try:\n            service = self.v1.read_namespaced_service(self.ingress_service_name, self.ingress_namespace)\n            if service.status.load_balancer and service.status.load_balancer.ingress:\n                ip = service.status.load_balancer.ingress[0].ip\n                if ip:\n                    return ip\n            return None\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Error getting external IP for ingress {self.ingress_service_name}.{self.ingress_namespace}: {e}\")\n            return None\n    \n    def create_cloudflare_dns_route(self, hostname):\n        \"\"\"Create DNS route using cloudflared for public services\"\"\"\n        try:\n            print(f\"üåê Creating Cloudflare DNS route for {hostname}\")\n            \n            cmd = [\n                'kubectl', 'exec', '-n', 'cloudflare-tunnel', \n                'deployment/cloudflared', '--', 'cloudflared', \n                'tunnel', 'route', 'dns', '--overwrite-dns', \n                'homelab-tunnel', hostname\n            ]\n            result = subprocess.run(cmd, capture_output=True, text=True)\n            if result.returncode == 0:\n                print(f\"‚úÖ Created Cloudflare DNS route for {hostname}\")\n                return True\n            else:\n                print(f\"‚ö†Ô∏è  Cloudflare DNS route creation failed for {hostname}: {result.stderr}\")\n                # Try without overwrite flag as fallback\n                cmd_fallback = [\n                    'kubectl', 'exec', '-n', 'cloudflare-tunnel', \n                    'deployment/cloudflared', '--', 'cloudflared', \n                    'tunnel', 'route', 'dns', 'homelab-tunnel', \n                    hostname\n                ]\n                result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)\n                if result_fallback.returncode == 0:\n                    print(f\"‚úÖ Created Cloudflare DNS route for {hostname} (fallback)\")\n                    return True\n                else:\n                    print(f\"‚ùå Failed to create Cloudflare DNS route for {hostname}: {result_fallback.stderr}\")\n                    return False\n        except Exception as e:\n            print(f\"‚ùå Error creating Cloudflare DNS route for {hostname}: {e}\")\n            return False\n    \n    def create_internal_dns_entry(self, hostname, ip_address):\n        \"\"\"Create internal DNS entry using MetalLB IP via Cloudflare API\"\"\"\n        try:\n            print(f\"üè† Creating internal DNS entry for {hostname} -> {ip_address}\")\n            \n            # Get Cloudflare API credentials from environment or secret\n            api_token = os.environ.get('CLOUDFLARE_API_TOKEN')\n            if not api_token:\n                print(\"‚ö†Ô∏è  CLOUDFLARE_API_TOKEN not found in environment variables\")\n                return False\n            \n            # Extract domain from hostname (e.g., \"service.internal.example.com\" -> \"example.com\")\n            domain_parts = hostname.split('.')\n            if len(domain_parts) < 2:\n                print(f\"‚ö†Ô∏è  Invalid hostname format: {hostname}\")\n                return False\n            \n            # Get domain (last two parts: example.com)\n            domain = '.'.join(domain_parts[-2:])\n            subdomain = '.'.join(domain_parts[:-2]) if len(domain_parts) > 2 else '@'\n            \n            print(f\"üîç Domain: {domain}, Subdomain: {subdomain}\")\n            \n            # Get zone ID for the domain\n            zone_id = self.get_cloudflare_zone_id(domain, api_token)\n            if not zone_id:\n                print(f\"‚ùå Could not find zone ID for domain: {domain}\")\n                return False\n            \n            # Check if record already exists\n            existing_record = self.get_existing_dns_record(zone_id, subdomain, domain, api_token)\n            \n            if existing_record:\n                # Update existing record if IP is different\n                if existing_record.get('content') != ip_address:\n                    print(f\"üîÑ Updating existing DNS record for {hostname}\")\n                    success = self.update_dns_record(zone_id, existing_record['id'], subdomain, ip_address, api_token)\n                    if success:\n                        print(f\"‚úÖ Updated DNS record for {hostname} -> {ip_address}\")\n                    return success\n                else:\n                    print(f\"‚ÑπÔ∏è  DNS record for {hostname} already exists with correct IP\")\n                    return True\n            else:\n                # Create new record\n                print(f\"üÜï Creating new DNS record for {hostname}\")\n                success = self.create_dns_record(zone_id, subdomain, ip_address, api_token, domain)\n                if success:\n                    print(f\"‚úÖ Created DNS record for {hostname} -> {ip_address}\")\n                return success\n            \n        except Exception as e:\n            print(f\"‚ùå Error creating internal DNS entry for {hostname}: {e}\")\n            return False\n    \n    def get_cloudflare_zone_id(self, domain, api_token):\n        \"\"\"Get Cloudflare zone ID for a domain\"\"\"\n        try:\n            import requests\n            \n            headers = {\n                'Authorization': f'Bearer {api_token}',\n                'Content-Type': 'application/json'\n            }\n            \n            url = f'https://api.cloudflare.com/client/v4/zones?name={domain}'\n            response = requests.get(url, headers=headers, timeout=10)\n            \n            if response.status_code == 200:\n                data = response.json()\n                if data.get('success') and data.get('result'):\n                    zone_id = data['result'][0]['id']\n                    print(f\"‚úÖ Found zone ID for {domain}: {zone_id}\")\n                    return zone_id\n                else:\n                    print(f\"‚ùå No zone found for domain: {domain}\")\n                    return None\n            else:\n                print(f\"‚ùå Failed to get zone ID: {response.status_code} - {response.text}\")\n                return None\n                \n        except Exception as e:\n            print(f\"‚ùå Error getting zone ID: {e}\")\n            return None\n    \n    def get_existing_dns_record(self, zone_id, subdomain, domain, api_token):\n        \"\"\"Get existing DNS record if it exists\"\"\"\n        try:\n            import requests\n            \n            headers = {\n                'Authorization': f'Bearer {api_token}',\n                'Content-Type': 'application/json'\n            }\n            \n            # Construct the full name for the record\n            record_name = f\"{subdomain}.{domain}\" if subdomain != '@' else domain\n            \n            url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records?name={record_name}&type=A'\n            response = requests.get(url, headers=headers, timeout=10)\n            \n            if response.status_code == 200:\n                data = response.json()\n                if data.get('success') and data.get('result'):\n                    return data['result'][0]  # Return first matching record\n                else:\n                    return None\n            else:\n                print(f\"‚ùå Failed to check existing records: {response.status_code}\")\n                return None\n                \n        except Exception as e:\n            print(f\"‚ùå Error checking existing DNS record: {e}\")\n            return None\n    \n    def create_dns_record(self, zone_id, subdomain, ip_address, api_token, domain):\n        \"\"\"Create a new DNS A record\"\"\"\n        try:\n            import requests\n            \n            headers = {\n                'Authorization': f'Bearer {api_token}',\n                'Content-Type': 'application/json'\n            }\n            \n            # Construct the full name for the record\n            record_name = f\"{subdomain}.{domain}\" if subdomain != '@' else domain\n            \n            data = {\n                'type': 'A',\n                'name': record_name,\n                'content': ip_address,\n                'ttl': 300,  # 5 minutes TTL\n                'proxied': False  # Don't proxy internal services\n            }\n            \n            url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records'\n            response = requests.post(url, headers=headers, json=data, timeout=10)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get('success'):\n                    return True\n                else:\n                    print(f\"‚ùå Failed to create DNS record: {result.get('errors', [])}\")\n                    return False\n            else:\n                print(f\"‚ùå Failed to create DNS record: {response.status_code} - {response.text}\")\n                return False\n                \n        except Exception as e:\n            print(f\"‚ùå Error creating DNS record: {e}\")\n            return False\n    \n    def update_dns_record(self, zone_id, record_id, subdomain, ip_address, api_token):\n        \"\"\"Update an existing DNS A record\"\"\"\n        try:\n            import requests\n            \n            headers = {\n                'Authorization': f'Bearer {api_token}',\n                'Content-Type': 'application/json'\n            }\n            \n            # Include the record name to avoid 9000 DNS name is invalid errors\n            # Cloudflare requires 'name' when updating certain records\n            data = {\n                'type': 'A',\n                'name': subdomain if subdomain != '@' else None,\n                'content': ip_address,\n                'ttl': 300,\n                'proxied': False\n            }\n            # Remove name if it's None to avoid sending null\n            if data['name'] is None:\n                del data['name']\n            \n            url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records/{record_id}'\n            response = requests.put(url, headers=headers, json=data, timeout=10)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get('success'):\n                    return True\n                else:\n                    print(f\"‚ùå Failed to update DNS record: {result.get('errors', [])}\")\n                    return False\n            else:\n                print(f\"‚ùå Failed to update DNS record: {response.status_code} - {response.text}\")\n                return False\n                \n        except Exception as e:\n            print(f\"‚ùå Error updating DNS record: {e}\")\n            return False\n    \n    def calculate_config_hash(self, config_data):\n        \"\"\"Calculate hash of tunnel configuration to detect changes\"\"\"\n        config_str = yaml.dump(config_data, default_flow_style=False, sort_keys=True)\n        return hashlib.md5(config_str.encode()).hexdigest()\n    \n    def update_tunnel_config(self, service_name, hostname, namespace, port):\n        \"\"\"Update the tunnel configuration for public services\"\"\"\n        try:\n            print(f\"üîß Adding tunnel ingress rule for {hostname}\")\n            \n            # Get current config\n            configmap = self.v1.read_namespaced_config_map(\"cloudflared-config\", \"cloudflare-tunnel\")\n            current_config = configmap.data[\"config.yaml\"]\n            \n            # Parse the YAML config\n            config_data = yaml.safe_load(current_config)\n            \n            # Check if rule already exists\n            for rule in config_data.get(\"ingress\", []):\n                if isinstance(rule, dict) and rule.get(\"hostname\") == hostname:\n                    print(f\"‚ö†Ô∏è  Tunnel ingress rule for {hostname} already exists\")\n                    return True\n            \n            # Add new rule before catch-all\n            new_rule = {\n                \"hostname\": hostname,\n                \"service\": f\"http://{service_name}.{namespace}.svc.cluster.local:{port}\"\n            }\n            \n            # Insert before the catch-all rule\n            ingress_rules = config_data.get(\"ingress\", [])\n            for i, rule in enumerate(ingress_rules):\n                if isinstance(rule, dict) and rule.get(\"service\") == \"http_status:404\":\n                    ingress_rules.insert(i, new_rule)\n                    break\n            else:\n                ingress_rules.append(new_rule)\n            \n            config_data[\"ingress\"] = ingress_rules\n            \n            # Calculate new config hash\n            new_hash = self.calculate_config_hash(config_data)\n            \n            # Only update if config actually changed\n            if new_hash != self.tunnel_config_hash:\n                # Update the configmap\n                updated_config = yaml.dump(config_data, default_flow_style=False)\n                configmap.data[\"config.yaml\"] = updated_config\n                self.v1.patch_namespaced_config_map(\"cloudflared-config\", \"cloudflare-tunnel\", configmap)\n                \n                # Update hash and timestamp\n                self.tunnel_config_hash = new_hash\n                self.last_config_update = time.time()\n                \n                # Note: cloudflared will automatically reload config when ConfigMap changes\n                # No need to restart the deployment manually\n                print(f\"‚ÑπÔ∏è  Config updated, cloudflared will automatically reload\")\n                \n                print(f\"‚úÖ Updated tunnel config for {hostname}\")\n            else:\n                print(f\"‚ÑπÔ∏è  Tunnel config unchanged for {hostname}, skipping restart\")\n            \n            return True\n            \n        except Exception as e:\n            print(f\"‚ùå Error updating tunnel config: {e}\")\n            return False\n    \n    def process_service_event(self, event_type, service):\n        \"\"\"Process service events\"\"\"\n        try:\n            if not service or not service.metadata:\n                return\n                \n            service_name = service.metadata.name\n            namespace = service.metadata.namespace\n            labels = service.metadata.labels or {}\n            \n            # Check if DNS is enabled for this service\n            if labels.get(DNS_ENABLED_LABEL) != \"true\":\n                return\n            \n            hostname = labels.get(DNS_HOSTNAME_LABEL)\n            exposure_type = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)\n            \n            if not hostname:\n                print(f\"‚ö†Ô∏è  Service {service_name}.{namespace} has DNS enabled but no hostname specified\")\n                return\n            \n            print(f\"üîç Processing {event_type} event for {service_name}.{namespace} -> {hostname} (exposure: {exposure_type})\")\n            \n            if event_type in [\"ADDED\", \"MODIFIED\", \"EXISTING\"]:\n                if exposure_type == EXPOSURE_PUBLIC:\n                    # Handle public services (tunneled)\n                    port = self.get_service_port(service_name, namespace)\n                    dns_success = self.create_cloudflare_dns_route(hostname)\n                    if dns_success:\n                        self.update_tunnel_config(service_name, hostname, namespace, port)\n                elif exposure_type == EXPOSURE_INTERNAL:\n                    # Handle internal services via Ingress controller IP (MetalLB)\n                    external_ip = self.get_ingress_external_ip()\n                    if external_ip:\n                        self.create_internal_dns_entry(hostname, external_ip)\n                    else:\n                        print(f\"‚ö†Ô∏è  Ingress controller has no external IP/hostname yet; cannot create DNS for {hostname}\")\n                else:\n                    print(f\"‚ö†Ô∏è  Unknown exposure type '{exposure_type}' for service {service_name}.{namespace}\")\n                    \n        except Exception as e:\n            print(f\"‚ùå Error processing service event: {e}\")\n    \n    def get_services_with_dns_label(self):\n        \"\"\"Get all services that have DNS enabled using label selector\"\"\"\n        try:\n            # Use label selector for efficient querying\n            label_selector = f\"{DNS_ENABLED_LABEL}=true\"\n            services = self.v1.list_service_for_all_namespaces(label_selector=label_selector)\n            return services.items\n        except Exception as e:\n            print(f\"‚ùå Error getting services with DNS label: {e}\")\n            return []\n    \n    def main(self):\n        \"\"\"Main controller loop\"\"\"\n        try:\n            print(\"üîç Loading Kubernetes config...\")\n            import sys\n            sys.stdout.flush()\n            \n            # Debug environment variables\n            print(f\"üîç KUBERNETES_SERVICE_HOST: {os.environ.get('KUBERNETES_SERVICE_HOST', 'Not set')}\")\n            print(f\"üîç KUBERNETES_SERVICE_PORT: {os.environ.get('KUBERNETES_SERVICE_PORT', 'Not set')}\")\n            print(f\"üîç KUBECONFIG: {os.environ.get('KUBECONFIG', 'Not set')}\")\n            \n            # Load kubeconfig - try in-cluster first, then fallback to kubeconfig\n            try:\n                config.load_incluster_config()\n                print(\"‚úÖ Kubernetes in-cluster config loaded\")\n            except Exception as e:\n                print(f\"‚ö†Ô∏è  In-cluster config failed: {e}\")\n                print(\"üîÑ Trying kubeconfig...\")\n                config.load_kube_config()\n                print(\"‚úÖ Kubernetes kubeconfig loaded\")\n            \n            # Initialize Kubernetes clients after config is loaded\n            self.v1 = client.CoreV1Api()\n            self.apps_v1 = client.AppsV1Api()\n            \n            sys.stdout.flush()\n            \n            print(\"‚úÖ Service Controller initialized\")\n            sys.stdout.flush()\n            \n            # Test Kubernetes API connection\n            try:\n                print(\"üîç Testing Kubernetes API connection...\")\n                sys.stdout.flush()\n                # Try a simple API call to test connection\n                self.v1.list_namespace()\n                print(\"‚úÖ Kubernetes API connection successful\")\n                sys.stdout.flush()\n            except Exception as e:\n                print(f\"‚ùå Kubernetes API connection failed: {e}\")\n                print(\"üîÑ Retrying in 10 seconds...\")\n                sys.stdout.flush()\n                time.sleep(10)\n                return self.main()\n            \n            # Process existing services with DNS enabled\n            print(\"üîç Processing existing services with DNS enabled...\")\n            sys.stdout.flush()\n            existing_services = self.get_services_with_dns_label()\n            for service in existing_services:\n                self.process_service_event(\"EXISTING\", service)\n            \n            # Watch for changes using label selector for efficiency\n            print(\"üëÄ Watching for service changes with DNS enabled...\")\n            sys.stdout.flush()\n            w = watch.Watch()\n            \n            # Watch only services with DNS enabled label\n            label_selector = f\"{DNS_ENABLED_LABEL}=true\"\n            try:\n                for event in w.stream(self.v1.list_service_for_all_namespaces, label_selector=label_selector):\n                    self.process_service_event(event[\"type\"], event[\"object\"])\n            except Exception as e:\n                print(f\"‚ùå Watch stream error: {e}\")\n                print(\"üîÑ Restarting watch in 5 seconds...\")\n                sys.stdout.flush()\n                time.sleep(5)\n                return self.main()\n                \n        except Exception as e:\n            print(f\"‚ùå Controller error: {e}\")\n            import traceback\n            traceback.print_exc()\n            time.sleep(10)\n            self.main()\n\nif __name__ == \"__main__\":\n    controller = ServiceController()\n    controller.main()\n"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: service-controller
rules:
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "patch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: service-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: service-controller
subjects:
  - kind: ServiceAccount
    name: service-controller
    namespace: cloudflare-tunnel
