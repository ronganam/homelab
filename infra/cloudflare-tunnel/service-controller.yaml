---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
  labels:
    app: service-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: service-controller
  template:
    metadata:
      labels:
        app: service-controller
    spec:
      serviceAccountName: service-controller
      containers:
      - name: service-controller
        image: python:3.13-alpine
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "üîç Installing dependencies..."
          apk add --no-cache curl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          mv kubectl /usr/local/bin/
          pip install kubernetes pyyaml requests --quiet
          
          echo "üîç Starting Service Controller..."
          python -u /app/controller.py
        env:
        - name: CLOUDFLARE_API_TOKEN
          valueFrom:
            secretKeyRef:
              name: cloudflare-api-token
              key: token
        volumeMounts:
        - name: controller-script
          mountPath: /app
        resources:
          limits:
            memory: 256Mi
            cpu: 200m
          requests:
            memory: 128Mi
            cpu: 100m
      volumes:
      - name: controller-script
        configMap:
          name: service-controller-script
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: service-controller-script
  namespace: cloudflare-tunnel
data:
  controller.py: |
    #!/usr/bin/env python3
    
    import os
    import time
    import yaml
    import json
    import subprocess
    import hashlib
    from kubernetes import client, config, watch
    
    # Label constants
    DNS_ENABLED_LABEL = "dns.service-controller.io/enabled"
    DNS_HOSTNAME_LABEL = "dns.service-controller.io/hostname"
    EXPOSURE_TYPE_LABEL = "exposure.service-controller.io/type"  # "public" or "internal"
    
    # Exposure types
    EXPOSURE_PUBLIC = "public"
    EXPOSURE_INTERNAL = "internal"
    
    class ServiceController:
        def __init__(self):
            self.v1 = None
            self.apps_v1 = None
            self.tunnel_config_hash = None
            self.last_config_update = 0
            
        def get_service_port(self, service_name, namespace):
            """Get the port of a service"""
            try:
                service = self.v1.read_namespaced_service(service_name, namespace)
                if service.spec.ports:
                    return service.spec.ports[0].port
                return 80
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting port for {service_name}.{namespace}: {e}")
                return 80
        
        def get_service_external_ip(self, service_name, namespace):
            """Get the external IP of a service (for MetalLB)"""
            try:
                service = self.v1.read_namespaced_service(service_name, namespace)
                if service.status.load_balancer and service.status.load_balancer.ingress:
                    return service.status.load_balancer.ingress[0].ip
                return None
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting external IP for {service_name}.{namespace}: {e}")
                return None
        
        def create_cloudflare_dns_route(self, hostname):
            """Create DNS route using cloudflared for public services"""
            try:
                print(f"üåê Creating Cloudflare DNS route for {hostname}")
                
                cmd = [
                    'kubectl', 'exec', '-n', 'cloudflare-tunnel', 
                    'deployment/cloudflared', '--', 'cloudflared', 
                    'tunnel', 'route', 'dns', '--overwrite-dns', 
                    'homelab-tunnel', hostname
                ]
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"‚úÖ Created Cloudflare DNS route for {hostname}")
                    return True
                else:
                    print(f"‚ö†Ô∏è  Cloudflare DNS route creation failed for {hostname}: {result.stderr}")
                    # Try without overwrite flag as fallback
                    cmd_fallback = [
                        'kubectl', 'exec', '-n', 'cloudflare-tunnel', 
                        'deployment/cloudflared', '--', 'cloudflared', 
                        'tunnel', 'route', 'dns', 'homelab-tunnel', 
                        hostname
                    ]
                    result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)
                    if result_fallback.returncode == 0:
                        print(f"‚úÖ Created Cloudflare DNS route for {hostname} (fallback)")
                        return True
                    else:
                        print(f"‚ùå Failed to create Cloudflare DNS route for {hostname}: {result_fallback.stderr}")
                        return False
            except Exception as e:
                print(f"‚ùå Error creating Cloudflare DNS route for {hostname}: {e}")
                return False
        
        def create_internal_dns_entry(self, hostname, ip_address):
            """Create internal DNS entry using MetalLB IP via Cloudflare API"""
            try:
                print(f"üè† Creating internal DNS entry for {hostname} -> {ip_address}")
                
                # Get Cloudflare API credentials from environment or secret
                api_token = os.environ.get('CLOUDFLARE_API_TOKEN')
                if not api_token:
                    print("‚ö†Ô∏è  CLOUDFLARE_API_TOKEN not found in environment variables")
                    return False
                
                # Extract domain from hostname (e.g., "service.internal.example.com" -> "example.com")
                domain_parts = hostname.split('.')
                if len(domain_parts) < 2:
                    print(f"‚ö†Ô∏è  Invalid hostname format: {hostname}")
                    return False
                
                # Get domain (last two parts: example.com)
                domain = '.'.join(domain_parts[-2:])
                subdomain = '.'.join(domain_parts[:-2]) if len(domain_parts) > 2 else '@'
                
                print(f"üîç Domain: {domain}, Subdomain: {subdomain}")
                
                # Get zone ID for the domain
                zone_id = self.get_cloudflare_zone_id(domain, api_token)
                if not zone_id:
                    print(f"‚ùå Could not find zone ID for domain: {domain}")
                    return False
                
                # Check if record already exists
                existing_record = self.get_existing_dns_record(zone_id, subdomain, domain, api_token)
                
                if existing_record:
                    # Update existing record if IP is different
                    if existing_record.get('content') != ip_address:
                        print(f"üîÑ Updating existing DNS record for {hostname}")
                        success = self.update_dns_record(zone_id, existing_record['id'], subdomain, ip_address, api_token)
                        if success:
                            print(f"‚úÖ Updated DNS record for {hostname} -> {ip_address}")
                        return success
                    else:
                        print(f"‚ÑπÔ∏è  DNS record for {hostname} already exists with correct IP")
                        return True
                else:
                    # Create new record
                    print(f"üÜï Creating new DNS record for {hostname}")
                    success = self.create_dns_record(zone_id, subdomain, ip_address, api_token, domain)
                    if success:
                        print(f"‚úÖ Created DNS record for {hostname} -> {ip_address}")
                    return success
                
            except Exception as e:
                print(f"‚ùå Error creating internal DNS entry for {hostname}: {e}")
                return False
        
        def get_cloudflare_zone_id(self, domain, api_token):
            """Get Cloudflare zone ID for a domain"""
            try:
                import requests
                
                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }
                
                url = f'https://api.cloudflare.com/client/v4/zones?name={domain}'
                response = requests.get(url, headers=headers, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success') and data.get('result'):
                        zone_id = data['result'][0]['id']
                        print(f"‚úÖ Found zone ID for {domain}: {zone_id}")
                        return zone_id
                    else:
                        print(f"‚ùå No zone found for domain: {domain}")
                        return None
                else:
                    print(f"‚ùå Failed to get zone ID: {response.status_code} - {response.text}")
                    return None
                    
            except Exception as e:
                print(f"‚ùå Error getting zone ID: {e}")
                return None
        
        def get_existing_dns_record(self, zone_id, subdomain, domain, api_token):
            """Get existing DNS record if it exists"""
            try:
                import requests
                
                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }
                
                # Construct the full name for the record
                record_name = f"{subdomain}.{domain}" if subdomain != '@' else domain
                
                url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records?name={record_name}&type=A'
                response = requests.get(url, headers=headers, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success') and data.get('result'):
                        return data['result'][0]  # Return first matching record
                    else:
                        return None
                else:
                    print(f"‚ùå Failed to check existing records: {response.status_code}")
                    return None
                    
            except Exception as e:
                print(f"‚ùå Error checking existing DNS record: {e}")
                return None
        
        def create_dns_record(self, zone_id, subdomain, ip_address, api_token, domain):
            """Create a new DNS A record"""
            try:
                import requests
                
                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }
                
                # Construct the full name for the record
                record_name = f"{subdomain}.{domain}" if subdomain != '@' else domain
                
                data = {
                    'type': 'A',
                    'name': record_name,
                    'content': ip_address,
                    'ttl': 300,  # 5 minutes TTL
                    'proxied': False  # Don't proxy internal services
                }
                
                url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records'
                response = requests.post(url, headers=headers, json=data, timeout=10)
                
                if response.status_code == 200:
                    result = response.json()
                    if result.get('success'):
                        return True
                    else:
                        print(f"‚ùå Failed to create DNS record: {result.get('errors', [])}")
                        return False
                else:
                    print(f"‚ùå Failed to create DNS record: {response.status_code} - {response.text}")
                    return False
                    
            except Exception as e:
                print(f"‚ùå Error creating DNS record: {e}")
                return False
        
        def update_dns_record(self, zone_id, record_id, subdomain, ip_address, api_token):
            """Update an existing DNS A record"""
            try:
                import requests
                
                headers = {
                    'Authorization': f'Bearer {api_token}',
                    'Content-Type': 'application/json'
                }
                
                # Include the record name to avoid 9000 DNS name is invalid errors
                # Cloudflare requires 'name' when updating certain records
                data = {
                    'type': 'A',
                    'name': subdomain if subdomain != '@' else None,
                    'content': ip_address,
                    'ttl': 300,
                    'proxied': False
                }
                # Remove name if it's None to avoid sending null
                if data['name'] is None:
                    del data['name']
                
                url = f'https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records/{record_id}'
                response = requests.put(url, headers=headers, json=data, timeout=10)
                
                if response.status_code == 200:
                    result = response.json()
                    if result.get('success'):
                        return True
                    else:
                        print(f"‚ùå Failed to update DNS record: {result.get('errors', [])}")
                        return False
                else:
                    print(f"‚ùå Failed to update DNS record: {response.status_code} - {response.text}")
                    return False
                    
            except Exception as e:
                print(f"‚ùå Error updating DNS record: {e}")
                return False
        
        def calculate_config_hash(self, config_data):
            """Calculate hash of tunnel configuration to detect changes"""
            config_str = yaml.dump(config_data, default_flow_style=False, sort_keys=True)
            return hashlib.md5(config_str.encode()).hexdigest()
        
        def update_tunnel_config(self, service_name, hostname, namespace, port):
            """Update the tunnel configuration for public services"""
            try:
                print(f"üîß Adding tunnel ingress rule for {hostname}")
                
                # Get current config
                configmap = self.v1.read_namespaced_config_map("cloudflared-config", "cloudflare-tunnel")
                current_config = configmap.data["config.yaml"]
                
                # Parse the YAML config
                config_data = yaml.safe_load(current_config)
                
                # Check if rule already exists
                for rule in config_data.get("ingress", []):
                    if isinstance(rule, dict) and rule.get("hostname") == hostname:
                        print(f"‚ö†Ô∏è  Tunnel ingress rule for {hostname} already exists")
                        return True
                
                # Add new rule before catch-all
                new_rule = {
                    "hostname": hostname,
                    "service": f"http://{service_name}.{namespace}.svc.cluster.local:{port}"
                }
                
                # Insert before the catch-all rule
                ingress_rules = config_data.get("ingress", [])
                for i, rule in enumerate(ingress_rules):
                    if isinstance(rule, dict) and rule.get("service") == "http_status:404":
                        ingress_rules.insert(i, new_rule)
                        break
                else:
                    ingress_rules.append(new_rule)
                
                config_data["ingress"] = ingress_rules
                
                # Calculate new config hash
                new_hash = self.calculate_config_hash(config_data)
                
                # Only update if config actually changed
                if new_hash != self.tunnel_config_hash:
                    # Update the configmap
                    updated_config = yaml.dump(config_data, default_flow_style=False)
                    configmap.data["config.yaml"] = updated_config
                    self.v1.patch_namespaced_config_map("cloudflared-config", "cloudflare-tunnel", configmap)
                    
                    # Update hash and timestamp
                    self.tunnel_config_hash = new_hash
                    self.last_config_update = time.time()
                    
                    # Note: cloudflared will automatically reload config when ConfigMap changes
                    # No need to restart the deployment manually
                    print(f"‚ÑπÔ∏è  Config updated, cloudflared will automatically reload")
                    
                    print(f"‚úÖ Updated tunnel config for {hostname}")
                else:
                    print(f"‚ÑπÔ∏è  Tunnel config unchanged for {hostname}, skipping restart")
                
                return True
                
            except Exception as e:
                print(f"‚ùå Error updating tunnel config: {e}")
                return False
        
        def process_service_event(self, event_type, service):
            """Process service events"""
            try:
                if not service or not service.metadata:
                    return
                    
                service_name = service.metadata.name
                namespace = service.metadata.namespace
                labels = service.metadata.labels or {}
                
                # Check if DNS is enabled for this service
                if labels.get(DNS_ENABLED_LABEL) != "true":
                    return
                
                hostname = labels.get(DNS_HOSTNAME_LABEL)
                exposure_type = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)
                
                if not hostname:
                    print(f"‚ö†Ô∏è  Service {service_name}.{namespace} has DNS enabled but no hostname specified")
                    return
                
                print(f"üîç Processing {event_type} event for {service_name}.{namespace} -> {hostname} (exposure: {exposure_type})")
                
                if event_type in ["ADDED", "MODIFIED", "EXISTING"]:
                    if exposure_type == EXPOSURE_PUBLIC:
                        # Handle public services (tunneled)
                        port = self.get_service_port(service_name, namespace)
                        dns_success = self.create_cloudflare_dns_route(hostname)
                        if dns_success:
                            self.update_tunnel_config(service_name, hostname, namespace, port)
                    elif exposure_type == EXPOSURE_INTERNAL:
                        # Handle internal services (MetalLB)
                        external_ip = self.get_service_external_ip(service_name, namespace)
                        if external_ip:
                            self.create_internal_dns_entry(hostname, external_ip)
                        else:
                            print(f"‚ö†Ô∏è  Service {service_name}.{namespace} is marked as internal but has no external IP")
                    else:
                        print(f"‚ö†Ô∏è  Unknown exposure type '{exposure_type}' for service {service_name}.{namespace}")
                        
            except Exception as e:
                print(f"‚ùå Error processing service event: {e}")
        
        def get_services_with_dns_label(self):
            """Get all services that have DNS enabled using label selector"""
            try:
                # Use label selector for efficient querying
                label_selector = f"{DNS_ENABLED_LABEL}=true"
                services = self.v1.list_service_for_all_namespaces(label_selector=label_selector)
                return services.items
            except Exception as e:
                print(f"‚ùå Error getting services with DNS label: {e}")
                return []
        
        def main(self):
            """Main controller loop"""
            try:
                print("üîç Loading Kubernetes config...")
                import sys
                sys.stdout.flush()
                
                # Debug environment variables
                print(f"üîç KUBERNETES_SERVICE_HOST: {os.environ.get('KUBERNETES_SERVICE_HOST', 'Not set')}")
                print(f"üîç KUBERNETES_SERVICE_PORT: {os.environ.get('KUBERNETES_SERVICE_PORT', 'Not set')}")
                print(f"üîç KUBECONFIG: {os.environ.get('KUBECONFIG', 'Not set')}")
                
                # Load kubeconfig - try in-cluster first, then fallback to kubeconfig
                try:
                    config.load_incluster_config()
                    print("‚úÖ Kubernetes in-cluster config loaded")
                except Exception as e:
                    print(f"‚ö†Ô∏è  In-cluster config failed: {e}")
                    print("üîÑ Trying kubeconfig...")
                    config.load_kube_config()
                    print("‚úÖ Kubernetes kubeconfig loaded")
                
                # Initialize Kubernetes clients after config is loaded
                self.v1 = client.CoreV1Api()
                self.apps_v1 = client.AppsV1Api()
                
                sys.stdout.flush()
                
                print("‚úÖ Service Controller initialized")
                sys.stdout.flush()
                
                # Test Kubernetes API connection
                try:
                    print("üîç Testing Kubernetes API connection...")
                    sys.stdout.flush()
                    # Try a simple API call to test connection
                    self.v1.list_namespace()
                    print("‚úÖ Kubernetes API connection successful")
                    sys.stdout.flush()
                except Exception as e:
                    print(f"‚ùå Kubernetes API connection failed: {e}")
                    print("üîÑ Retrying in 10 seconds...")
                    sys.stdout.flush()
                    time.sleep(10)
                    return self.main()
                
                # Process existing services with DNS enabled
                print("üîç Processing existing services with DNS enabled...")
                sys.stdout.flush()
                existing_services = self.get_services_with_dns_label()
                for service in existing_services:
                    self.process_service_event("EXISTING", service)
                
                # Watch for changes using label selector for efficiency
                print("üëÄ Watching for service changes with DNS enabled...")
                sys.stdout.flush()
                w = watch.Watch()
                
                # Watch only services with DNS enabled label
                label_selector = f"{DNS_ENABLED_LABEL}=true"
                try:
                    for event in w.stream(self.v1.list_service_for_all_namespaces, label_selector=label_selector):
                        self.process_service_event(event["type"], event["object"])
                except Exception as e:
                    print(f"‚ùå Watch stream error: {e}")
                    print("üîÑ Restarting watch in 5 seconds...")
                    sys.stdout.flush()
                    time.sleep(5)
                    return self.main()
                    
            except Exception as e:
                print(f"‚ùå Controller error: {e}")
                import traceback
                traceback.print_exc()
                time.sleep(10)
                self.main()
    
    if __name__ == "__main__":
        controller = ServiceController()
        controller.main()
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: service-controller
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "patch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: service-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: service-controller
subjects:
- kind: ServiceAccount
  name: service-controller
  namespace: cloudflare-tunnel
