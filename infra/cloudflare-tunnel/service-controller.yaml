apiVersion: apps/v1
kind: Deployment
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
  labels:
    app: service-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: service-controller
  template:
    metadata:
      labels:
        app: service-controller
    spec:
      serviceAccountName: service-controller
      containers:
        - name: service-controller
          image: python:3.14-alpine
          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "üîç Installing dependencies..."
              apk add --no-cache curl
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              mv kubectl /usr/local/bin/
              pip install kubernetes pyyaml cloudflare --quiet

              echo "üîç Starting Service Controller..."
              python -u /app/controller.py
          env:
            - name: CLOUDFLARE_API_TOKEN
              valueFrom:
                secretKeyRef:
                  name: cloudflare-api-token
                  key: token
            - name: INGRESS_NAMESPACE
              value: ingress-nginx
            - name: INGRESS_SERVICE_NAME
              value: ingress-nginx-controller
          volumeMounts:
            - name: controller-script
              mountPath: /app
          resources:
            limits:
              memory: 512Mi
              cpu: 500m
            requests:
              memory: 128Mi
              cpu: 100m
      volumes:
        - name: controller-script
          configMap:
            name: service-controller-script
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: service-controller-script
  namespace: cloudflare-tunnel
data:
  controller.py: "#!/usr/bin/env python3\n\nimport os\nimport time\nimport yaml\nimport subprocess\nimport hashlib\nimport logging\nimport re\nfrom kubernetes import client, config, watch\nimport threading\nfrom cloudflare import Cloudflare\n\nLOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO').upper()\nlogging.basicConfig(level=LOG_LEVEL, format=\"%(asctime)s %(levelname)s %(name)s %(message)s\")\nlogger = logging.getLogger(\"service-controller\")\nRECONCILE_INTERVAL_SEC = int(os.environ.get('RECONCILE_INTERVAL_SEC', '300'))\n\n# Label constants\nDNS_ENABLED_LABEL = \"dns.service-controller.io/enabled\"\nDNS_HOSTNAME_LABEL = \"dns.service-controller.io/hostname\"\nEXPOSURE_TYPE_LABEL = \"exposure.service-controller.io/type\"  # \"public\" or \"internal\"\n\n# Exposure types\nEXPOSURE_PUBLIC = \"public\"\nEXPOSURE_INTERNAL = \"internal\"\n\nclass ServiceController:\n    def __init__(self):\n        self.v1 = None\n        self.apps_v1 = None\n        self.tunnel_config_hash = None\n        self.last_config_update = 0\n        # Ingress settings for internal services\n        self.ingress_namespace = os.environ.get('INGRESS_NAMESPACE', 'ingress-nginx')\n        self.ingress_service_name = os.environ.get('INGRESS_SERVICE_NAME', 'ingress-nginx-controller')\n        # Cloudflare client cache\n        self.cf = None\n\n    def ensure_cf_client(self):\n        \"\"\"Initialize Cloudflare client if not already created.\"\"\"\n        if self.cf is not None:\n            return self.cf\n        api_token = os.environ.get('CLOUDFLARE_API_TOKEN')\n        if not api_token:\n            raise RuntimeError(\"CLOUDFLARE_API_TOKEN is not set\")\n        self.cf = Cloudflare(api_token=api_token)\n        return self.cf\n\n    def get_service_port(self, service_name, namespace):\n        \"\"\"Get the port of a service\"\"\"\n        try:\n            service = self.v1.read_namespaced_service(service_name, namespace)\n            if service.spec.ports:\n                return service.spec.ports[0].port\n            return 80\n        except Exception as e:\n            logger.warning(\"Error getting port for %s.%s: %s\", service_name, namespace, e)\n            return 80\n\n    def get_ingress_external_ip(self):\n        \"\"\"Get the external IP of the ingress controller service for internal HTTPS\"\"\"\n        try:\n            service = self.v1.read_namespaced_service(self.ingress_service_name, self.ingress_namespace)\n            if service.status.load_balancer and service.status.load_balancer.ingress:\n                ip = service.status.load_balancer.ingress[0].ip\n                if ip:\n                    return ip\n            return None\n        except Exception as e:\n            logger.warning(\"Error getting external IP for ingress %s.%s: %s\", self.ingress_service_name, self.ingress_namespace, e)\n            return None\n\n    def create_cloudflare_dns_route(self, hostname):\n        \"\"\"Create DNS route using cloudflared for public services\"\"\"\n        try:\n            # Skip creating if route already exists\n            if self.public_route_exists(hostname):\n                logger.debug(\"Cloudflare DNS route already exists for %s\", hostname)\n                return True\n\n            logger.debug(\"Ensuring Cloudflare DNS route for %s\", hostname)\n\n            hostname_norm = str(hostname).strip().lower().rstrip(\".\")\n            domain_parts = hostname_norm.split(\".\")\n            if len(domain_parts) < 2:\n                logger.warning(\"Invalid hostname for public DNS route: %s\", hostname)\n                return False\n            zone = \".\".join(domain_parts[-2:])\n\n            cmd = [\n                'kubectl', 'exec', '-n', 'cloudflare-tunnel',\n                'deployment/cloudflared', '--', 'cloudflared',\n                'tunnel', 'route', 'dns', '--overwrite-dns', '--zone', zone,\n                'homelab-tunnel', hostname\n            ]\n            result = subprocess.run(cmd, capture_output=True, text=True)\n            out = (result.stdout or \"\") + \"\\n\" + (result.stderr or \"\")\n            logger.debug(\"DNS route cmd rc=%s out='%s'\", result.returncode, out.strip())\n            if result.returncode == 0:\n                # Heuristics: avoid noisy info logs; treat as ensure at debug level\n                if re.search(r\"exist|already\", out, re.IGNORECASE):\n                    logger.debug(\"Cloudflare DNS route already existed for %s\", hostname)\n                else:\n                    logger.debug(\"Ensured Cloudflare DNS route for %s\", hostname)\n                return True\n            else:\n                logger.warning(\"Cloudflare DNS route creation failed for %s: %s\", hostname, result.stderr.strip())\n                # Try without overwrite flag as fallback\n                cmd_fallback = [\n                    'kubectl', 'exec', '-n', 'cloudflare-tunnel',\n                    'deployment/cloudflared', '--', 'cloudflared',\n                    'tunnel', 'route', 'dns', '--zone', zone,\n                    'homelab-tunnel', hostname\n                ]\n                result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)\n                fb_out = (result_fallback.stdout or \"\") + \"\\n\" + (result_fallback.stderr or \"\")\n                logger.debug(\"Fallback DNS route rc=%s out='%s'\", result_fallback.returncode, fb_out.strip())\n                if result_fallback.returncode == 0:\n                    if re.search(r\"exist|already\", fb_out, re.IGNORECASE):\n                        logger.debug(\"Cloudflare DNS route already existed for %s (fallback)\", hostname)\n                    else:\n                        logger.debug(\"Ensured Cloudflare DNS route for %s (fallback)\", hostname)\n                    return True\n                else:\n                    logger.error(\"Failed to create Cloudflare DNS route for %s: %s\", hostname, result_fallback.stderr.strip())\n                    return False\n        except subprocess.TimeoutExpired:\n            logger.warning(\"DNS route command timed out for %s\", hostname)\n            return False\n        except Exception as e:\n            logger.exception(\"Error creating Cloudflare DNS route for %s: %s\", hostname, e)\n            return False\n\n    def public_route_exists(self, hostname):\n        \"\"\"Check if a Cloudflare DNS route already exists for the hostname\"\"\"\n        try:\n            cmd = [\n                'kubectl', 'exec', '-n', 'cloudflare-tunnel',\n                'deployment/cloudflared', '--', 'cloudflared',\n                'tunnel', 'route', 'dns', 'homelab-tunnel', 'list'\n            ]\n            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)\n            if result.returncode != 0:\n                logger.debug(\"route list failed rc=%s stderr='%s'\", result.returncode, result.stderr.strip())\n                return False\n            out = result.stdout or \"\"\n            # Simple containment check; output is tabular, so contains hostname when present\n            exists = hostname in out\n            logger.debug(\"route exists for %s: %s\", hostname, exists)\n            return exists\n        except subprocess.TimeoutExpired:\n            logger.warning(\"Timeout checking route existence for %s\", hostname)\n            return False\n        except Exception as e:\n            logger.debug(\"Error checking route existence for %s: %s\", hostname, e)\n            return False\n\n    def create_internal_dns_entry(self, hostname, ip_address):\n        \"\"\"Ensure internal DNS entry using MetalLB IP via Cloudflare API\"\"\"\n        try:\n            logger.debug(\"Ensuring internal DNS entry for %s -> %s\", hostname, ip_address)\n\n            # Get Cloudflare API credentials from environment or secret\n            api_token = os.environ.get('CLOUDFLARE_API_TOKEN')\n            if not api_token:\n                logger.warning(\"CLOUDFLARE_API_TOKEN not found in environment variables\")\n                return False\n\n            # Extract domain from hostname (e.g., \"service.internal.example.com\" -> \"example.com\")\n            domain_parts = hostname.split('.')\n            if len(domain_parts) < 2:\n                print(f\"‚ö†Ô∏è  Invalid hostname format: {hostname}\")\n                return False\n\n            # Get domain (last two parts: example.com)\n            domain = '.'.join(domain_parts[-2:])\n            subdomain = '.'.join(domain_parts[:-2]) if len(domain_parts) > 2 else '@'\n\n            logger.debug(\"Domain: %s, Subdomain: %s\", domain, subdomain)\n\n            # Get zone ID for the domain\n            zone_id = self.get_cloudflare_zone_id(domain, api_token)\n            if not zone_id:\n                logger.error(\"Could not find zone ID for domain: %s\", domain)\n                return False\n\n            # Check if record already exists\n            existing_record = self.get_existing_dns_record(zone_id, subdomain, domain, api_token)\n\n            if existing_record:\n                # Update existing record if IP is different\n                if existing_record.get('content') != ip_address:\n                    logger.info(\"Updating internal DNS record for %s -> %s\", hostname, ip_address)\n                    success = self.update_dns_record(zone_id, existing_record['id'], subdomain, ip_address, api_token)\n                    return success\n                else:\n                    logger.debug(\"Internal DNS record for %s already correct\", hostname)\n                    return True\n            else:\n                # Create new record\n                logger.info(\"Creating internal DNS record for %s -> %s\", hostname, ip_address)\n                success = self.create_dns_record(zone_id, subdomain, ip_address, api_token, domain)\n                return success\n\n        except Exception as e:\n            logger.exception(\"Error creating internal DNS entry for %s: %s\", hostname, e)\n            return False\n\n    def get_cloudflare_zone_id(self, domain, api_token):\n        \"\"\"Get Cloudflare zone ID for a domain using SDK\"\"\"\n        try:\n            cf = self.ensure_cf_client()\n            zones = cf.zones.list(name=domain)\n            first_zone = None\n            for z in zones:\n                first_zone = z\n                break\n            if first_zone is not None:\n                zone_id = getattr(first_zone, 'id', None)\n                if zone_id is None and isinstance(first_zone, dict):\n                    zone_id = first_zone.get('id')\n                if zone_id:\n                    logger.debug(\"Found zone ID for %s: %s\", domain, zone_id)\n                    return zone_id\n            logger.error(\"No zone found for domain: %s\", domain)\n            return None\n        except Exception as e:\n            logger.exception(\"Error getting zone ID via SDK: %s\", e)\n            return None\n\n    def get_existing_dns_record(self, zone_id, subdomain, domain, api_token):\n        \"\"\"Get existing DNS A record if it exists using SDK\"\"\"\n        try:\n            cf = self.ensure_cf_client()\n            record_name = f\"{subdomain}.{domain}\" if subdomain != '@' else domain\n            records = cf.dns.records.list(zone_id=zone_id, name=record_name, type='A')\n            first_rec = None\n            for r in records:\n                first_rec = r\n                break\n            if first_rec is not None:\n                # Normalize minimal fields used by callers\n                rec_id = getattr(first_rec, 'id', None)\n                rec_content = getattr(first_rec, 'content', None)\n                rec_name = getattr(first_rec, 'name', None)\n                if isinstance(first_rec, dict):\n                    rec_id = rec_id or first_rec.get('id')\n                    rec_content = rec_content or first_rec.get('content')\n                    rec_name = rec_name or first_rec.get('name')\n                return {'id': rec_id, 'content': rec_content, 'name': rec_name}\n            return None\n        except Exception as e:\n            logger.exception(\"Error checking existing DNS record via SDK: %s\", e)\n            return None\n\n    def get_cloudflare_records_by_names(self, zone_id, api_token, names):\n        \"\"\"Fetch A records for provided FQDN names using SDK. Return map name->{ip,id}.\"\"\"\n        results = {}\n        try:\n            cf = self.ensure_cf_client()\n            for n in names:\n                recs = cf.dns.records.list(zone_id=zone_id, name=n, type='A')\n                first = None\n                for r in recs:\n                    first = r\n                    break\n                if first is not None:\n                    name_val = getattr(first, 'name', None)\n                    content_val = getattr(first, 'content', None)\n                    id_val = getattr(first, 'id', None)\n                    if isinstance(first, dict):\n                        name_val = name_val or first.get('name')\n                        content_val = content_val or first.get('content')\n                        id_val = id_val or first.get('id')\n                    key = (name_val or '').lower().rstrip('.')\n                    results[key] = {'ip': content_val, 'id': id_val}\n        except Exception as e:\n            logger.exception(\"Error fetching DNS records by names via SDK: %s\", e)\n        return results\n\n    def create_dns_record(self, zone_id, subdomain, ip_address, api_token, domain):\n        \"\"\"Create a new DNS A record using SDK. Proactively replace conflicting CNAME.\"\"\"\n        try:\n            record_name = f\"{subdomain}.{domain}\" if subdomain != '@' else domain\n            cf = self.ensure_cf_client()\n\n            # Proactively delete conflicting CNAME if present\n            cname_records = cf.dns.records.list(zone_id=zone_id, name=record_name, type='CNAME')\n            first_cname = None\n            for r in cname_records:\n                first_cname = r\n                break\n            if first_cname is not None:\n                rec_id = getattr(first_cname, 'id', None)\n                if rec_id is None and isinstance(first_cname, dict):\n                    rec_id = first_cname.get('id')\n                if rec_id:\n                    cf.dns.records.delete(zone_id=zone_id, dns_record_id=rec_id)\n                    logger.info(\"Deleted conflicting CNAME for %s\", record_name)\n\n            cf.dns.records.create(\n                zone_id=zone_id,\n                type='A',\n                name=record_name,\n                content=ip_address,\n                ttl=300,\n                proxied=False\n            )\n            return True\n        except Exception as e:\n            # Keep a helpful message if CNAME conflict arises due to race\n            msg = str(e).lower()\n            if ('81054' in msg or 'cname' in msg) and 'cf' in locals():\n                try:\n                    cname_records = cf.dns.records.list(zone_id=zone_id, name=record_name, type='CNAME')\n                    first_cname = None\n                    for r in cname_records:\n                        first_cname = r\n                        break\n                    if first_cname is not None:\n                        rec_id = getattr(first_cname, 'id', None)\n                        if rec_id is None and isinstance(first_cname, dict):\n                            rec_id = first_cname.get('id')\n                        if rec_id:\n                            cf.dns.records.delete(zone_id=zone_id, dns_record_id=rec_id)\n                            cf.dns.records.create(\n                                zone_id=zone_id,\n                                type='A',\n                                name=record_name,\n                                content=ip_address,\n                                ttl=300,\n                                proxied=False\n                            )\n                            return True\n                except Exception as e2:\n                    logger.exception(\"Retry after CNAME deletion failed: %s\", e2)\n            logger.exception(\"Error creating DNS record via SDK: %s\", e)\n            return False\n\n    def update_dns_record(self, zone_id, record_id, subdomain, ip_address, api_token):\n        \"\"\"Update an existing DNS A record using SDK\"\"\"\n        try:\n            cf = self.ensure_cf_client()\n            name_value = subdomain if subdomain != '@' else None\n            update_payload = {\n                'type': 'A',\n                'content': ip_address,\n                'ttl': 300,\n                'proxied': False\n            }\n            if name_value:\n                update_payload['name'] = name_value\n            cf.dns.records.update(zone_id=zone_id, dns_record_id=record_id, **update_payload)\n            return True\n        except Exception as e:\n            logger.exception(\"Error updating DNS record via SDK: %s\", e)\n            return False\n\n    def find_dns_record_by_name_and_type(self, zone_id, record_name, record_type, api_token):\n        \"\"\"Find a DNS record by exact name and type using SDK. Returns dict or None.\"\"\"\n        try:\n            cf = self.ensure_cf_client()\n            recs = cf.dns.records.list(zone_id=zone_id, name=record_name, type=record_type)\n            first = None\n            for r in recs:\n                first = r\n                break\n            if first is not None:\n                # Normalize to dict\n                rec_id = getattr(first, 'id', None)\n                rec_name = getattr(first, 'name', None)\n                rec_type = getattr(first, 'type', None)\n                rec_content = getattr(first, 'content', None)\n                if isinstance(first, dict):\n                    rec_id = rec_id or first.get('id')\n                    rec_name = rec_name or first.get('name')\n                    rec_type = rec_type or first.get('type')\n                    rec_content = rec_content or first.get('content')\n                return {'id': rec_id, 'name': rec_name, 'type': rec_type, 'content': rec_content}\n            return None\n        except Exception as e:\n            logger.exception(\"Error finding DNS record by name/type via SDK: %s\", e)\n            return None\n\n    def delete_dns_record(self, zone_id, record_id, api_token):\n        \"\"\"Delete a DNS record by id using SDK. Returns True on success.\"\"\"\n        try:\n            cf = self.ensure_cf_client()\n            cf.dns.records.delete(zone_id=zone_id, dns_record_id=record_id)\n            logger.info(\"Deleted DNS record id=%s\", record_id)\n            return True\n        except Exception as e:\n            logger.exception(\"Error deleting DNS record via SDK id=%s: %s\", record_id, e)\n            return False\n\n    def calculate_config_hash(self, config_data):\n        \"\"\"Calculate hash of tunnel configuration to detect changes\"\"\"\n        config_str = yaml.dump(config_data, default_flow_style=False, sort_keys=True)\n        return hashlib.md5(config_str.encode()).hexdigest()\n\n    def update_tunnel_config(self, service_name, hostname, namespace, port):\n        \"\"\"Update the tunnel configuration for public services\"\"\"\n        try:\n            logger.info(\"Adding tunnel ingress rule for %s\", hostname)\n\n            # Get current config\n            configmap = self.v1.read_namespaced_config_map(\"cloudflared-config\", \"cloudflare-tunnel\")\n            current_config = configmap.data[\"config.yaml\"]\n\n            # Parse the YAML config\n            config_data = yaml.safe_load(current_config)\n\n            # Desired service target for this hostname\n            desired_service = f\"http://{service_name}.{namespace}.svc.cluster.local:{port}\"\n            logger.debug(\"Desired service for %s: %s\", hostname, desired_service)\n\n            # Normalize hostname and check existing rules\n            normalized_hostname = str(hostname).strip().lower().rstrip(\".\")\n            logger.debug(\"Normalized hostname: '%s'\", normalized_hostname)\n            ingress_rules = config_data.get(\"ingress\", [])\n            existing_index = None\n            config_changed = False\n            for i, rule in enumerate(ingress_rules):\n                if not isinstance(rule, dict):\n                    continue\n                current_hostname = str(rule.get(\"hostname\", \"\")).strip().lower().rstrip(\".\")\n                logger.debug(\"Checking rule %s: current_hostname='%s' rule=%s\", i, current_hostname, rule)\n                if current_hostname == normalized_hostname:\n                    existing_index = i\n                    current_service = rule.get(\"service\")\n                    logger.debug(\"Found existing rule at index %s, current service: '%s', desired: '%s'\", i, current_service, desired_service)\n                    if current_service != desired_service:\n                        logger.info(\"Updating tunnel ingress rule for %s -> %s\", hostname, desired_service)\n                        rule[\"service\"] = desired_service\n                        ingress_rules[i] = rule\n                        config_changed = True\n                    else:\n                        logger.info(\"Tunnel ingress rule for %s already exists\", hostname)\n                        return True\n                    break\n\n            # Add new rule before catch-all if not found\n            if existing_index is None:\n                logger.debug(\"No existing rule found for %s, adding new\", normalized_hostname)\n                new_rule = {\n                    \"hostname\": hostname,\n                    \"service\": desired_service\n                }\n                \n                # Insert before the catch-all rule\n                for i, rule in enumerate(ingress_rules):\n                    if isinstance(rule, dict) and rule.get(\"service\") == \"http_status:404\":\n                        logger.debug(\"Inserting before catch-all at index %s\", i)\n                        ingress_rules.insert(i, new_rule)\n                        config_changed = True\n                        break\n                else:\n                    logger.debug(\"Appending to end (no catch-all found)\")\n                    ingress_rules.append(new_rule)\n                    config_changed = True\n\n            config_data[\"ingress\"] = ingress_rules\n\n            # Calculate new config hash\n            new_hash = self.calculate_config_hash(config_data)\n            logger.debug(\"New config hash: %s, previous: %s\", new_hash, self.tunnel_config_hash)\n\n            # Only update if config actually changed\n            if new_hash != self.tunnel_config_hash or config_changed:\n                # Update the configmap\n                updated_config = yaml.dump(config_data, default_flow_style=False)\n                configmap.data[\"config.yaml\"] = updated_config\n                self.v1.patch_namespaced_config_map(\"cloudflared-config\", \"cloudflare-tunnel\", configmap)\n                logger.info(\"Updated ConfigMap with new ingress rules\")\n\n                # Force cloudflared rollout by updating pod template annotation with the new hash\n                try:\n                    patch_body = {\n                        \"spec\": {\n                            \"template\": {\n                                \"metadata\": {\n                                    \"annotations\": {\n                                        \"service-controller.io/config-hash\": new_hash\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    self.apps_v1.patch_namespaced_deployment(\n                        name=\"cloudflared\",\n                        namespace=\"cloudflare-tunnel\",\n                        body=patch_body\n                    )\n                    logger.info(\"Triggered cloudflared rollout due to config change\")\n                except Exception as rollout_e:\n                    logger.warning(\"Failed to trigger cloudflared rollout: %s\", rollout_e)\n\n                # Update hash and timestamp\n                self.tunnel_config_hash = new_hash\n                self.last_config_update = time.time()\n\n                logger.info(\"Updated tunnel config for %s\", hostname)\n            else:\n                logger.info(\"Tunnel config unchanged for %s, skipping update\", hostname)\n\n            return True\n\n        except Exception as e:\n            logger.exception(\"Error updating tunnel config: %s\", e)\n            return False\n\n    def build_desired_public_rules(self):\n        \"\"\"Build desired ingress rules from all public, DNS-enabled services\"\"\"\n        desired = []\n        services = self.get_services_with_dns_label()\n        for service in services:\n            try:\n                labels = (service.metadata and service.metadata.labels) or {}\n                if labels.get(DNS_ENABLED_LABEL) != \"true\":\n                    continue\n                exposure = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)\n                if exposure != EXPOSURE_PUBLIC:\n                    continue\n                hostname = labels.get(DNS_HOSTNAME_LABEL)\n                if not hostname:\n                    continue\n                port = self.get_service_port(service.metadata.name, service.metadata.namespace)\n                desired_service = f\"http://{service.metadata.name}.{service.metadata.namespace}.svc.cluster.local:{port}\"\n                desired.append({\n                    \"hostname\": str(hostname).strip().lower().rstrip('.'),\n                    \"service\": desired_service,\n                })\n            except Exception as e:\n                logger.debug(\"Error building desired rule from %s.%s: %s\", service.metadata.name, service.metadata.namespace, e)\n        return desired\n\n    def get_current_public_rules(self, config_data):\n        \"\"\"Extract current public ingress rules from config (excluding catch-all)\"\"\"\n        rules = []\n        for rule in config_data.get(\"ingress\", []) or []:\n            if not isinstance(rule, dict):\n                continue\n            if rule.get(\"service\") == \"http_status:404\":\n                continue\n            hostname = str(rule.get(\"hostname\", \"\")).strip().lower().rstrip('.')\n            service_target = rule.get(\"service\")\n            if hostname and service_target:\n                rules.append({\"hostname\": hostname, \"service\": service_target})\n        return rules\n\n    def reconcile_tunnel_config(self):\n        \"\"\"Reconcile entire set of public ingress rules. Only patch if changed.\"\"\"\n        try:\n            # Load current configmap\n            configmap = self.v1.read_namespaced_config_map(\"cloudflared-config\", \"cloudflare-tunnel\")\n            current_config = configmap.data[\"config.yaml\"]\n            config_data = yaml.safe_load(current_config) or {}\n\n            # Capture the existing hash BEFORE any mutation so we compare against\n            # the actual current state rather than a cached internal hash.\n            existing_hash = self.calculate_config_hash(config_data)\n\n            desired_rules = self.build_desired_public_rules()\n            current_rules = self.get_current_public_rules(config_data)\n\n            # Sort for stable comparison\n            def sort_key(r):\n                return (r.get(\"hostname\", \"\"), r.get(\"service\", \"\"))\n\n            desired_sorted = sorted(desired_rules, key=sort_key)\n            current_sorted = sorted(current_rules, key=sort_key)\n\n            # Log state and differences succinctly\n            desired_fmt = [f\"{r['hostname']} -> {r['service']}\" for r in desired_sorted]\n            current_fmt = [f\"{r['hostname']} -> {r['service']}\" for r in current_sorted]\n            logger.info(\"Desired rules: %s\", desired_fmt)\n            logger.info(\"Current rules: %s\", current_fmt)\n\n            if desired_sorted == current_sorted:\n                logger.info(\"Diff: none (no changes needed)\")\n                return True\n\n            # Compute a concise diff summary\n            desired_map = {r[\"hostname\"]: r[\"service\"] for r in desired_sorted}\n            current_map = {r[\"hostname\"]: r[\"service\"] for r in current_sorted}\n            desired_set = {(h, s) for h, s in desired_map.items()}\n            current_set = {(h, s) for h, s in current_map.items()}\n            additions = sorted(list(desired_set - current_set))\n            removals = sorted(list(current_set - desired_set))\n            intersect_hosts = set(desired_map.keys()) & set(current_map.keys())\n            changes = sorted([h for h in intersect_hosts if desired_map[h] != current_map[h]])\n            logger.info(\"Diff: additions=%s removals=%s changes=%s\", additions, removals, changes)\n\n            logger.info(\"Updating rules to match desired state\")\n            # Rebuild ingress: keep catch-all at end\n            new_ingress = []\n            for r in desired_sorted:\n                new_ingress.append({\"hostname\": r[\"hostname\"], \"service\": r[\"service\"]})\n            # Preserve catch-all 404 if present; otherwise append one\n            catch_all = None\n            for rule in config_data.get(\"ingress\", []) or []:\n                if isinstance(rule, dict) and rule.get(\"service\") == \"http_status:404\":\n                    catch_all = rule\n                    break\n            if catch_all is None:\n                catch_all = {\"service\": \"http_status:404\"}\n            new_ingress.append(catch_all)\n\n            config_data[\"ingress\"] = new_ingress\n\n            # Patch only if the new config differs from what is currently stored\n            new_hash = self.calculate_config_hash(config_data)\n            if new_hash == existing_hash:\n                logger.info(\"Reconciled config equals current ConfigMap; skipping patch\")\n                return True\n\n            updated_config = yaml.dump(config_data, default_flow_style=False)\n            configmap.data[\"config.yaml\"] = updated_config\n            self.v1.patch_namespaced_config_map(\"cloudflared-config\", \"cloudflare-tunnel\", configmap)\n            logger.info(\"Updated ConfigMap with reconciled ingress rules\")\n\n            # Trigger rollout\n            try:\n                patch_body = {\n                    \"spec\": {\n                        \"template\": {\n                            \"metadata\": {\n                                \"annotations\": {\n                                    \"service-controller.io/config-hash\": new_hash\n                                }\n                            }\n                        }\n                    }\n                }\n                self.apps_v1.patch_namespaced_deployment(\n                    name=\"cloudflared\",\n                    namespace=\"cloudflare-tunnel\",\n                    body=patch_body\n                )\n                logger.info(\"Triggered cloudflared rollout due to reconciled config change\")\n            except Exception as rollout_e:\n                logger.warning(\"Failed to trigger cloudflared rollout: %s\", rollout_e)\n\n            self.tunnel_config_hash = new_hash\n            self.last_config_update = time.time()\n            logger.info(\"Reconciled tunnel config applied\")\n            return True\n        except Exception as e:\n            logger.exception(\"Error reconciling tunnel config: %s\", e)\n            return False\n\n    def reconcile_internal_dns(self):\n        \"\"\"Reconcile internal DNS A records for all internal, DNS-enabled services.\n        Only log summaries and update when diffs exist.\"\"\"\n        try:\n            services = self.get_services_with_dns_label()\n            hostnames = []\n            for service in services:\n                labels = (service.metadata and service.metadata.labels) or {}\n                if labels.get(DNS_ENABLED_LABEL) != \"true\":\n                    continue\n                if labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC) != EXPOSURE_INTERNAL:\n                    continue\n                hostname = labels.get(DNS_HOSTNAME_LABEL)\n                if hostname:\n                    hostnames.append(hostname)\n\n            if not hostnames:\n                logger.debug(\"No internal services to reconcile\")\n                return True\n\n            external_ip = self.get_ingress_external_ip()\n            if not external_ip:\n                logger.debug(\"No ingress IP available; skipping internal DNS reconcile\")\n                return True\n\n            # Assume all internal hostnames share the same zone (domain is last 2 parts)\n            domain = '.'.join(hostnames[0].split('.')[-2:])\n            names = [h.lower().rstrip('.') for h in hostnames]\n\n            api_token = os.environ.get('CLOUDFLARE_API_TOKEN')\n            if not api_token:\n                logger.debug(\"No CLOUDFLARE_API_TOKEN; skipping internal DNS reconcile\")\n                return True\n\n            zone_id = self.get_cloudflare_zone_id(domain, api_token)\n            if not zone_id:\n                logger.debug(\"No zone ID for domain %s; skipping internal DNS reconcile\", domain)\n                return True\n\n            current = self.get_cloudflare_records_by_names(zone_id, api_token, names)\n\n            desired_map = {n: external_ip for n in names}\n            current_map = {n: info.get('ip') for n, info in current.items()}\n\n            desired_fmt = [f\"{n} -> {ip}\" for n, ip in sorted(desired_map.items())]\n            current_fmt = [f\"{n} -> {ip}\" for n, ip in sorted(current_map.items())]\n            logger.info(\"Desired internal DNS: %s\", desired_fmt)\n            logger.info(\"Current internal DNS: %s\", current_fmt)\n\n            additions = sorted([n for n in names if n not in current_map])\n            changes = sorted([n for n in names if current_map.get(n) and current_map[n] != external_ip])\n            removals = []  # We do not remove stray records here\n\n            if not additions and not changes and not removals:\n                logger.info(\"Internal DNS diff: none (no changes needed)\")\n                return True\n\n            logger.info(\"Internal DNS diff: additions=%s changes=%s removals=%s\", additions, changes, removals)\n            logger.info(\"Updating internal DNS records to match desired state\")\n\n            # Apply upserts\n            for n in additions:\n                sub = n.replace(f\".{domain}\", \"\") if n.endswith(f\".{domain}\") else n\n                self.create_dns_record(zone_id, sub, external_ip, api_token, domain)\n            for n in changes:\n                sub = n.replace(f\".{domain}\", \"\") if n.endswith(f\".{domain}\") else n\n                rec = current.get(n)\n                if rec and rec.get('id'):\n                    self.update_dns_record(zone_id, rec['id'], sub, external_ip, api_token)\n\n            logger.info(\"Internal DNS reconcile complete\")\n            return True\n        except Exception as e:\n            logger.exception(\"Error reconciling internal DNS: %s\", e)\n            return False\n\n    def process_service_event(self, event_type, service):\n        \"\"\"Process service events\"\"\"\n        try:\n            if not service or not service.metadata:\n                return\n\n            service_name = service.metadata.name\n            namespace = service.metadata.namespace\n            labels = service.metadata.labels or {}\n\n            # Check if DNS is enabled for this service\n            if labels.get(DNS_ENABLED_LABEL) != \"true\":\n                return\n\n            hostname = labels.get(DNS_HOSTNAME_LABEL)\n            exposure_type = labels.get(EXPOSURE_TYPE_LABEL, EXPOSURE_PUBLIC)\n\n            if not hostname:\n                logger.warning(\"Service %s.%s has DNS enabled but no hostname specified\", service_name, namespace)\n                return\n\n            logger.info(\"Processing %s event for %s.%s -> %s (exposure: %s)\", event_type, service_name, namespace, hostname, exposure_type)\n\n            if event_type in [\"ADDED\", \"MODIFIED\", \"EXISTING\"]:\n                if exposure_type == EXPOSURE_PUBLIC:\n                    # Public services: ensure DNS route exists quietly; reconciliation handles config changes\n                    self.create_cloudflare_dns_route(hostname)\n                elif exposure_type == EXPOSURE_INTERNAL:\n                    # Internal services: ensure DNS quietly at event time\n                    external_ip = self.get_ingress_external_ip()\n                    if external_ip:\n                        self.create_internal_dns_entry(hostname, external_ip)\n                    else:\n                        logger.debug(\"Ingress controller has no external IP/hostname yet; skip ensure for %s\", hostname)\n                else:\n                    logger.warning(\"Unknown exposure type '%s' for service %s.%s\", exposure_type, service_name, namespace)\n\n        except Exception as e:\n            logger.exception(\"Error processing service event: %s\", e)\n\n    def reconcile_all(self):\n        \"\"\"Reconcile all DNS-enabled services periodically\"\"\"\n        # Summary-only reconciles: compute diffs and apply if needed\n        self.reconcile_internal_dns()\n        self.reconcile_tunnel_config()\n\n    def start_periodic_reconciliation(self):\n        def periodic_reconcile():\n            while True:\n                time.sleep(RECONCILE_INTERVAL_SEC)\n                try:\n                    self.reconcile_all()\n                except Exception as e:\n                    logger.exception(\"Error in periodic reconciliation: %s\", e)\n        thread = threading.Thread(target=periodic_reconcile, daemon=True)\n        thread.start()\n        logger.info(\"Started periodic reconciliation every %s seconds\", RECONCILE_INTERVAL_SEC)\n\n    def get_services_with_dns_label(self):\n        \"\"\"Get all services that have DNS enabled using label selector\"\"\"\n        try:\n            # Use label selector for efficient querying\n            label_selector = f\"{DNS_ENABLED_LABEL}=true\"\n            services = self.v1.list_service_for_all_namespaces(label_selector=label_selector)\n            return services.items\n        except Exception as e:\n            print(f\"‚ùå Error getting services with DNS label: {e}\")\n            return []\n\n    def main(self):\n        \"\"\"Main controller loop\"\"\"\n        try:\n            logger.info(\"Loading Kubernetes config...\")\n\n            # Debug environment variables\n            logger.debug(\"KUBERNETES_SERVICE_HOST: %s\", os.environ.get('KUBERNETES_SERVICE_HOST', 'Not set'))\n            logger.debug(\"KUBERNETES_SERVICE_PORT: %s\", os.environ.get('KUBERNETES_SERVICE_PORT', 'Not set'))\n            logger.debug(\"KUBECONFIG: %s\", os.environ.get('KUBECONFIG', 'Not set'))\n\n            # Load kubeconfig - try in-cluster first, then fallback to kubeconfig\n            try:\n                config.load_incluster_config()\n                logger.info(\"Kubernetes in-cluster config loaded\")\n            except Exception as e:\n                logger.warning(\"In-cluster config failed: %s\", e)\n                logger.info(\"Trying kubeconfig...\")\n                config.load_kube_config()\n                logger.info(\"Kubernetes kubeconfig loaded\")\n\n            # Initialize Kubernetes clients after config is loaded\n            self.v1 = client.CoreV1Api()\n            self.apps_v1 = client.AppsV1Api()\n\n            logger.info(\"Service Controller initialized\")\n\n            # Test Kubernetes API connection\n            try:\n                logger.info(\"Testing Kubernetes API connection...\")\n                # Try a simple API call to test connection\n                self.v1.list_namespace()\n                logger.info(\"Kubernetes API connection successful\")\n            except Exception as e:\n                logger.error(\"Kubernetes API connection failed: %s\", e)\n                logger.info(\"Retrying in 10 seconds...\")\n                time.sleep(10)\n                return self.main()\n\n            # Initial full reconcile\n            logger.info(\"Performing initial full reconciliation...\")\n            self.reconcile_all()\n\n            # Start periodic reconciliation thread\n            self.start_periodic_reconciliation()\n\n            # Watch for changes using label selector for efficiency\n            logger.info(\"Watching for service changes with DNS enabled...\")\n            w = watch.Watch()\n\n            # Watch only services with DNS enabled label\n            label_selector = f\"{DNS_ENABLED_LABEL}=true\"\n            try:\n                for event in w.stream(self.v1.list_service_for_all_namespaces, label_selector=label_selector):\n                    self.process_service_event(event[\"type\"], event[\"object\"])\n            except Exception as e:\n                logger.error(\"Watch stream error: %s\", e)\n                logger.info(\"Restarting watch in 5 seconds...\")\n                time.sleep(5)\n                return self.main()\n\n        except Exception as e:\n            logger.exception(\"Controller error: %s\", e)\n            time.sleep(10)\n            self.main()\n\nif __name__ == \"__main__\":\n    controller = ServiceController()\n    controller.main()"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: service-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: service-controller
rules:
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "patch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: service-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: service-controller
subjects:
  - kind: ServiceAccount
    name: service-controller
    namespace: cloudflare-tunnel
