---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
  labels:
    app: tunnel-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tunnel-controller
  template:
    metadata:
      labels:
        app: tunnel-controller
    spec:
      serviceAccountName: tunnel-controller
      containers:
      - name: tunnel-controller
        image: python:3.11-alpine
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "üîç Installing dependencies..."
          apk add --no-cache curl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          mv kubectl /usr/local/bin/
          pip install kubernetes pyyaml --quiet
          
          echo "üîç Starting Simple Tunnel Controller..."
          python -u /app/controller.py
        volumeMounts:
        - name: controller-script
          mountPath: /app
        resources:
          limits:
            memory: 256Mi
            cpu: 200m
          requests:
            memory: 128Mi
            cpu: 100m
      volumes:
      - name: controller-script
        configMap:
          name: tunnel-controller-script
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tunnel-controller-script
  namespace: cloudflare-tunnel
data:
  controller.py: |
    #!/usr/bin/env python3
    
    import os
    import time
    import yaml
    import json
    import subprocess
    from kubernetes import client, config, watch
    
    def get_service_port(service_name, namespace):
        """Get the port of a service"""
        try:
            v1 = client.CoreV1Api()
            service = v1.read_namespaced_service(service_name, namespace)
            if service.spec.ports:
                return service.spec.ports[0].port
            return 80
        except Exception as e:
            print(f"‚ö†Ô∏è  Error getting port for {service_name}.{namespace}: {e}")
            return 80
    
    def create_dns_route(hostname):
        """Create DNS route using cloudflared"""
        try:
            print(f"üåê Creating DNS route for {hostname}")
            
            # Create DNS route with overwrite flag to replace existing records
            # Correct syntax: flags before arguments
            cmd = [
                'kubectl', 'exec', '-n', 'cloudflare-tunnel', 
                'deployment/cloudflared', '--', 'cloudflared', 
                'tunnel', 'route', 'dns', '--overwrite-dns', 
                'homelab-tunnel', hostname
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                print(f"‚úÖ Created DNS route for {hostname}")
            else:
                print(f"‚ö†Ô∏è  DNS route creation failed for {hostname}: {result.stderr}")
                # Try without overwrite flag as fallback
                cmd_fallback = [
                    'kubectl', 'exec', '-n', 'cloudflare-tunnel', 
                    'deployment/cloudflared', '--', 'cloudflared', 
                    'tunnel', 'route', 'dns', 'homelab-tunnel', 
                    hostname
                ]
                result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)
                if result_fallback.returncode == 0:
                    print(f"‚úÖ Created DNS route for {hostname} (fallback)")
                else:
                    print(f"‚ùå Failed to create DNS route for {hostname}: {result_fallback.stderr}")
        except Exception as e:
            print(f"‚ùå Error creating DNS route for {hostname}: {e}")
    
    def update_tunnel_config(service_name, hostname, namespace, port):
        """Update the tunnel configuration"""
        try:
            print(f"üîß Adding ingress rule for {hostname}")
            
            v1 = client.CoreV1Api()
            
            # Get current config
            configmap = v1.read_namespaced_config_map("cloudflared-config", "cloudflare-tunnel")
            current_config = configmap.data["config.yaml"]
            
            # Parse the YAML config
            config_data = yaml.safe_load(current_config)
            
            # Check if rule already exists
            for rule in config_data.get("ingress", []):
                if isinstance(rule, dict) and rule.get("hostname") == hostname:
                    print(f"‚ö†Ô∏è  Ingress rule for {hostname} already exists")
                    return
            
            # Add new rule before catch-all
            new_rule = {
                "hostname": hostname,
                "service": f"http://{service_name}.{namespace}.svc.cluster.local:{port}"
            }
            
            # Insert before the catch-all rule
            ingress_rules = config_data.get("ingress", [])
            for i, rule in enumerate(ingress_rules):
                if isinstance(rule, dict) and rule.get("service") == "http_status:404":
                    ingress_rules.insert(i, new_rule)
                    break
            else:
                ingress_rules.append(new_rule)
            
            config_data["ingress"] = ingress_rules
            
            # Update the configmap
            updated_config = yaml.dump(config_data, default_flow_style=False)
            configmap.data["config.yaml"] = updated_config
            v1.patch_namespaced_config_map("cloudflared-config", "cloudflare-tunnel", configmap)
            
            # Restart cloudflared deployment
            apps_v1 = client.AppsV1Api()
            apps_v1.patch_namespaced_deployment(
                name="cloudflared",
                namespace="cloudflare-tunnel",
                body={"spec": {"template": {"metadata": {"annotations": {"kubectl.kubernetes.io/restartedAt": str(int(time.time()))}}}}}
            )
            
            print(f"‚úÖ Added ingress rule for {hostname}")
            
        except Exception as e:
            print(f"‚ùå Error updating tunnel config: {e}")
    
    def process_service_event(event_type, service):
        """Process service events"""
        try:
            if not service or not service.metadata:
                return
                
            service_name = service.metadata.name
            namespace = service.metadata.namespace
            hostname = service.metadata.annotations.get("cloudflare.com/tunnel-hostname") if service.metadata.annotations else None
            
            if not hostname:
                return
            
            print(f"üîç Processing {event_type} event for {service_name}.{namespace} -> {hostname}")
            
            if event_type in ["ADDED", "MODIFIED", "EXISTING"]:
                port = get_service_port(service_name, namespace)
                create_dns_route(hostname)
                update_tunnel_config(service_name, hostname, namespace, port)
                
        except Exception as e:
            print(f"‚ùå Error processing service event: {e}")
    
    def main():
        """Main controller loop"""
        try:
            print("üîç Loading Kubernetes config...")
            import sys
            sys.stdout.flush()
            # Load kubeconfig
            config.load_incluster_config()
            print("‚úÖ Kubernetes config loaded")
            sys.stdout.flush()
            
            v1 = client.CoreV1Api()
            print("‚úÖ Kubernetes client created")
            sys.stdout.flush()
            
            # Process existing services
            print("üîç Processing existing services with annotations...")
            sys.stdout.flush()
            services = v1.list_service_for_all_namespaces()
            for service in services.items:
                if service.metadata.annotations and "cloudflare.com/tunnel-hostname" in service.metadata.annotations:
                    process_service_event("EXISTING", service)
            
            # Watch for changes
            print("üëÄ Watching for service changes...")
            sys.stdout.flush()
            w = watch.Watch()
            for event in w.stream(v1.list_service_for_all_namespaces):
                process_service_event(event["type"], event["object"])
                
        except Exception as e:
            print(f"‚ùå Controller error: {e}")
            import traceback
            traceback.print_exc()
            time.sleep(10)
            main()
    
    if __name__ == "__main__":
        main()
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: tunnel-controller
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "patch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tunnel-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tunnel-controller
subjects:
- kind: ServiceAccount
  name: tunnel-controller
  namespace: cloudflare-tunnel