---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
  labels:
    app: tunnel-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tunnel-controller
  template:
    metadata:
      labels:
        app: tunnel-controller
    spec:
      serviceAccountName: tunnel-controller
      containers:
      - name: tunnel-controller
        image: bitnami/kubectl:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "üîç Tunnel Controller started - watching for services with cloudflare.com/tunnel-hostname annotation"
          
          # Function to create tunnel route
          create_route() {
            local service_name=$1
            local hostname=$2
            local namespace=$3
            
            echo "üåê Creating tunnel route for $hostname -> $service_name.$namespace"
            
            # Extract domain from hostname
            domain=$(echo "$hostname" | cut -d'.' -f2-)
            service_subdomain=$(echo "$hostname" | cut -d'.' -f1)
            
            # Create the tunnel route using kubectl exec to run cloudflared in the cloudflared pod
            if kubectl exec -n cloudflare-tunnel deployment/cloudflared -- cloudflared tunnel route dns homelab-tunnel "$service_subdomain" "$domain" 2>/dev/null; then
              echo "‚úÖ Created route for $hostname"
            else
              echo "‚ö†Ô∏è  Route may already exist for $hostname"
            fi
          }
          
          # Function to delete tunnel route
          delete_route() {
            local hostname=$1
            echo "üóëÔ∏è  Deleting tunnel route for $hostname"
            # Note: cloudflared doesn't have a direct delete command, routes are managed automatically
            echo "‚ÑπÔ∏è  Route will be cleaned up automatically by Cloudflare"
          }
          
          # Watch for services with the annotation
          kubectl get services --all-namespaces --watch --output-watch-events -o json | \
          jq -r 'select(.type == "ADDED" or .type == "MODIFIED" or .type == "DELETED") | 
                 select(.object.metadata.annotations["cloudflare.com/tunnel-hostname"]) |
                 "\(.type)|\(.object.metadata.name)|\(.object.metadata.namespace)|\(.object.metadata.annotations["cloudflare.com/tunnel-hostname"])"' | \
          while IFS='|' read -r event_type service_name namespace hostname; do
            case "$event_type" in
              "ADDED"|"MODIFIED")
                create_route "$service_name" "$hostname" "$namespace"
                ;;
              "DELETED")
                delete_route "$hostname"
                ;;
            esac
          done
        resources:
          limits:
            memory: 128Mi
            cpu: 100m
          requests:
            memory: 64Mi
            cpu: 50m
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: tunnel-controller
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tunnel-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tunnel-controller
subjects:
- kind: ServiceAccount
  name: tunnel-controller
  namespace: cloudflare-tunnel