---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
  labels:
    app: tunnel-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tunnel-controller
  template:
    metadata:
      labels:
        app: tunnel-controller
    spec:
      serviceAccountName: tunnel-controller
      containers:
      - name: tunnel-controller
        image: bitnami/kubectl:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "üîç Simple Tunnel Controller started"
          
          # Function to create DNS route
          create_dns_route() {
            local hostname=$1
            echo "üåê Creating DNS route for $hostname"
            
            # Extract subdomain and domain
            subdomain=$(echo "$hostname" | cut -d'.' -f1)
            domain=$(echo "$hostname" | cut -d'.' -f2-)
            
            # Create DNS route
            if kubectl exec -n cloudflare-tunnel deployment/cloudflared -- cloudflared tunnel route dns homelab-tunnel "$subdomain" "$domain" 2>/dev/null; then
              echo "‚úÖ Created DNS route for $hostname"
            else
              echo "‚ö†Ô∏è  DNS route may already exist for $hostname"
            fi
          }
          
          # Function to add ingress rule
          add_ingress_rule() {
            local service_name=$1
            local hostname=$2
            local namespace=$3
            local port=$4
            
            echo "üîß Adding ingress rule for $hostname"
            
            # Get current config
            current_config=$(kubectl get configmap cloudflared-config -n cloudflare-tunnel -o jsonpath='{.data.config\.yaml}')
            
            # Check if rule already exists
            if echo "$current_config" | grep -q "hostname: $hostname"; then
              echo "‚ö†Ô∏è  Ingress rule for $hostname already exists"
              return
            fi
            
            # Create new rule
            new_rule="      - hostname: $hostname"$'\n'"        service: http://$service_name.$namespace.svc.cluster.local:$port"
            
            # Add rule before catch-all (simple approach)
            updated_config=$(echo "$current_config" | sed "s|service: http_status:404|$new_rule"$'\n'"      - service: http_status:404|")
            
            # Update configmap
            kubectl patch configmap cloudflared-config -n cloudflare-tunnel --type merge --patch "{\"data\":{\"config.yaml\":\"$(echo "$updated_config" | sed 's/"/\\"/g' | tr '\n' '\\n')\"}}"
            
            # Restart cloudflared
            kubectl rollout restart deployment/cloudflared -n cloudflare-tunnel
            
            echo "‚úÖ Added ingress rule for $hostname"
          }
          
          # Function to process service
          process_service() {
            local service_name=$1
            local hostname=$2
            local namespace=$3
            
            echo "üîç Processing service: $service_name.$namespace -> $hostname"
            
            # Get service port
            port=$(kubectl get service "$service_name" -n "$namespace" -o jsonpath='{.spec.ports[0].port}' 2>/dev/null || echo "80")
            
            # Create DNS route
            create_dns_route "$hostname"
            
            # Add ingress rule
            add_ingress_rule "$service_name" "$hostname" "$namespace" "$port"
          }
          
          # Process existing services
          echo "üîç Processing existing services with annotations..."
          kubectl get services --all-namespaces -o json | \
          jq -r '.items[] | select(.metadata.annotations["cloudflare.com/tunnel-hostname"]) | 
                 "\(.metadata.name)|\(.metadata.namespace)|\(.metadata.annotations["cloudflare.com/tunnel-hostname"])"' | \
          while IFS='|' read -r service_name namespace hostname; do
            if [ -n "$service_name" ] && [ -n "$namespace" ] && [ -n "$hostname" ]; then
              echo "üìã Found existing service: $service_name.$namespace with hostname $hostname"
              process_service "$service_name" "$hostname" "$namespace"
            fi
          done
          
          # Watch for new services
          echo "üëÄ Watching for service changes..."
          kubectl get services --all-namespaces --watch --output-watch-events -o json | \
          jq -r 'select(.type == "ADDED" or .type == "MODIFIED") | 
                 select(.object.metadata.annotations["cloudflare.com/tunnel-hostname"]) |
                 "\(.type)|\(.object.metadata.name)|\(.object.metadata.namespace)|\(.object.metadata.annotations["cloudflare.com/tunnel-hostname"])"' | \
          while IFS='|' read -r event_type service_name namespace hostname; do
            if [ -n "$service_name" ] && [ -n "$namespace" ] && [ -n "$hostname" ]; then
              echo "üìã $event_type event for: $service_name.$namespace with hostname $hostname"
              process_service "$service_name" "$hostname" "$namespace"
            fi
          done
        resources:
          limits:
            memory: 128Mi
            cpu: 100m
          requests:
            memory: 64Mi
            cpu: 50m
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: tunnel-controller
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "patch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tunnel-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tunnel-controller
subjects:
- kind: ServiceAccount
  name: tunnel-controller
  namespace: cloudflare-tunnel