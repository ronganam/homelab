---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
  labels:
    app: tunnel-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tunnel-controller
  template:
    metadata:
      labels:
        app: tunnel-controller
    spec:
      serviceAccountName: tunnel-controller
      containers:
      - name: tunnel-controller
        image: bitnami/kubectl:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "üîç Tunnel Controller started - watching for services with cloudflare.com/tunnel-hostname annotation"
          
          # Function to create tunnel route
          create_route() {
            local service_name=$1
            local hostname=$2
            local namespace=$3
            
            echo "üåê Creating tunnel route for $hostname -> $service_name.$namespace"
            
            # Create the tunnel route using kubectl exec to run cloudflared in the cloudflared pod
            if kubectl exec -n cloudflare-tunnel deployment/cloudflared -- cloudflared tunnel route dns homelab-tunnel "$hostname" 2>/dev/null; then
              echo "‚úÖ Created DNS route for $hostname"
            else
              echo "‚ö†Ô∏è  DNS route may already exist for $hostname"
            fi
            
            # Update tunnel configuration with ingress rule
            update_tunnel_config "$service_name" "$hostname" "$namespace"
          }
          
          # Function to update tunnel configuration
          update_tunnel_config() {
            local service_name=$1
            local hostname=$2
            local namespace=$3
            
            echo "üîß Updating tunnel configuration for $hostname"
            
            # Get current config
            current_config=$(kubectl get configmap cloudflared-config -n cloudflare-tunnel -o jsonpath='{.data.config\.yaml}')
            
            # Create new ingress rule
            new_rule="      - hostname: $hostname
        service: http://$service_name.$namespace.svc.cluster.local:80"
            
            # Check if rule already exists
            if echo "$current_config" | grep -q "hostname: $hostname"; then
              echo "‚ö†Ô∏è  Ingress rule for $hostname already exists"
              return
            fi
            
            # Add the new rule before the catch-all rule
            updated_config=$(echo "$current_config" | sed "/service: http_status:404/i\\
$new_rule")
            
            # Update the configmap
            echo "$updated_config" | kubectl patch configmap cloudflared-config -n cloudflare-tunnel --patch "{\"data\":{\"config.yaml\":\"$(echo "$updated_config" | sed 's/"/\\"/g' | tr '\n' '\\n')\"}}"
            
            # Restart cloudflared to pick up new config
            kubectl rollout restart deployment/cloudflared -n cloudflare-tunnel
            
            echo "‚úÖ Updated tunnel configuration for $hostname"
          }
          
          # Function to delete tunnel route
          delete_route() {
            local hostname=$1
            echo "üóëÔ∏è  Deleting tunnel route for $hostname"
            # Note: cloudflared doesn't have a direct delete command, routes are managed automatically
            echo "‚ÑπÔ∏è  Route will be cleaned up automatically by Cloudflare"
          }
          
          # Process existing services with annotations on startup
          echo "üîç Processing existing services with annotations..."
          kubectl get services --all-namespaces -o json | \
          jq -r '.items[] | select(.metadata.annotations["cloudflare.com/tunnel-hostname"]) | 
                 "EXISTING|\(.metadata.name)|\(.metadata.namespace)|\(.metadata.annotations["cloudflare.com/tunnel-hostname"])"' | \
          while IFS='|' read -r event_type service_name namespace hostname; do
            echo "üìã Found existing service: $service_name.$namespace with hostname $hostname"
            create_route "$service_name" "$hostname" "$namespace"
          done
          
          # Watch for services with the annotation
          kubectl get services --all-namespaces --watch --output-watch-events -o json | \
          jq -r 'select(.type == "ADDED" or .type == "MODIFIED" or .type == "DELETED") | 
                 select(.object.metadata.annotations["cloudflare.com/tunnel-hostname"]) |
                 "\(.type)|\(.object.metadata.name)|\(.object.metadata.namespace)|\(.object.metadata.annotations["cloudflare.com/tunnel-hostname"])"' | \
          while IFS='|' read -r event_type service_name namespace hostname; do
            case "$event_type" in
              "ADDED"|"MODIFIED")
                create_route "$service_name" "$hostname" "$namespace"
                ;;
              "DELETED")
                delete_route "$hostname"
                ;;
            esac
          done
        resources:
          limits:
            memory: 128Mi
            cpu: 100m
          requests:
            memory: 64Mi
            cpu: 50m
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tunnel-controller
  namespace: cloudflare-tunnel
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: tunnel-controller
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tunnel-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tunnel-controller
subjects:
- kind: ServiceAccount
  name: tunnel-controller
  namespace: cloudflare-tunnel